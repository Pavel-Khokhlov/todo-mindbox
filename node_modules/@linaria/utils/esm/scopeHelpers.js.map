{"version":3,"file":"scopeHelpers.js","names":["findIdentifiers","nonType","isNotNull","isRemoved","getBinding","path","binding","scope","node","name","undefined","reference","referencePath","force","isReferencedIdentifier","referencePaths","includes","referenced","references","push","isReferenced","kind","some","i","find","ancestor","isTSType","isFlowType","dereference","filter","length","dereferenceAll","map","identifierPath","referenceAll","forEach","deletingNodes","WeakSet","findParentForDelete","add","parent","parentPath","isProgram","isLogicalExpression","operator","mutate","p","replaceWith","type","value","isObjectProperty","key","get","isIdentifier","maybeDefineProperty","isCallExpression","matchesPattern","isAssignmentExpression","isForInStatement","left","isFunctionExpression","body","isObjectMethod","isClassMethod","isBlockStatement","listKey","prevStatement","isIfStatement","isReturnStatement","slice","every","statement","has","isVariableDeclarator","isExportNamedDeclaration","specifiers","declaration","isExportDefaultDeclaration","isTryStatement","isExportSpecifier","isConditionalExpression","list","referenceEnums","program","traverse","ExpressionStatement","expressionStatement","expression","callee","args","arg","fixed","removeUnreferenced","items","Set","item","hasReferences","forDeleting","constantViolations","identifier","removeWithRelated","result","sort","a","b","localeCompare","paths","rootPath","getProgramParent","clean","referencedIdentifiers","declared","deletingPath","remove","reduce","acc","join","fn","dereferenced","mutated","dead","assignments","assignment","Object","values","getOuterBindingIdentifiers","Identifier","isArrayPattern","elements"],"sources":["../src/scopeHelpers.ts"],"sourcesContent":["/* eslint-disable no-restricted-syntax */\n/* eslint @typescript-eslint/no-use-before-define: [\"error\", { \"functions\": false }] */\n\nimport type { Binding, NodePath } from '@babel/traverse';\nimport type { Identifier, JSXIdentifier, Program } from '@babel/types';\n\nimport findIdentifiers, { nonType } from './findIdentifiers';\nimport isNotNull from './isNotNull';\nimport isRemoved from './isRemoved';\n\nfunction getBinding(path: NodePath<Identifier | JSXIdentifier>) {\n  const binding = path.scope.getBinding(path.node.name);\n  if (!binding) {\n    return undefined;\n  }\n\n  return binding;\n}\n\nexport function reference(\n  path: NodePath<Identifier | JSXIdentifier>,\n  referencePath: NodePath = path,\n  force = false\n): void {\n  if (!force && !path.isReferencedIdentifier()) return;\n\n  const binding = getBinding(path);\n  if (!binding) return;\n\n  if (binding.referencePaths.includes(referencePath)) {\n    return;\n  }\n\n  binding.referenced = true;\n  binding.references += 1;\n  binding.referencePaths.push(referencePath ?? path);\n}\n\nfunction isReferenced(binding: Binding) {\n  if (!binding.referenced) {\n    return false;\n  }\n\n  // If it's a param binding, we can't just remove it\n  // because it brakes the function signature. Keep it alive for now.\n  if ((binding.kind as string) === 'param') {\n    return true;\n  }\n\n  // If all remaining references are in TS/Flow types, binding is unreferenced\n  return binding.referencePaths.some(\n    (i) => !i.find((ancestor) => ancestor.isTSType() || ancestor.isFlowType())\n  );\n}\n\nexport function dereference(\n  path: NodePath<Identifier | JSXIdentifier>\n): Binding | null {\n  const binding = getBinding(path);\n  if (!binding) return null;\n\n  if (!binding.referencePaths.includes(path)) {\n    return null;\n  }\n\n  binding.references -= 1;\n  binding.referencePaths = binding.referencePaths.filter((i) => i !== path);\n  binding.referenced = binding.referencePaths.length > 0;\n\n  return binding;\n}\n\nfunction dereferenceAll(path: NodePath): Binding[] {\n  return findIdentifiers([path])\n    .map((identifierPath) => dereference(identifierPath))\n    .filter(isNotNull);\n}\n\nexport function referenceAll(path: NodePath): void {\n  findIdentifiers([path]).forEach((identifierPath) =>\n    reference(identifierPath)\n  );\n}\n\nconst deletingNodes = new WeakSet<NodePath>();\n\nexport function findParentForDelete(path: NodePath): NodePath | null {\n  if (isRemoved(path)) return null;\n\n  deletingNodes.add(path);\n\n  const parent = path.parentPath;\n\n  if (!parent) return path;\n\n  if (parent.isProgram()) {\n    // Do not delete Program node\n    return path;\n  }\n\n  if (parent.isLogicalExpression({ operator: '&&' })) {\n    mutate(parent, (p) => {\n      p.replaceWith({\n        type: 'BooleanLiteral',\n        value: false,\n      });\n    });\n\n    return null;\n  }\n\n  if (parent.isObjectProperty()) {\n    // let's check if it is a special case with Object.defineProperty\n    const key = parent.get('key');\n    if (key.isIdentifier({ name: 'get' })) {\n      const maybeDefineProperty = parent.parentPath.parentPath;\n      if (\n        maybeDefineProperty?.isCallExpression() &&\n        maybeDefineProperty\n          .get('callee')\n          .matchesPattern('Object.defineProperty')\n      ) {\n        return findParentForDelete(maybeDefineProperty);\n      }\n    }\n\n    return findParentForDelete(parent);\n  }\n\n  if (parent.isAssignmentExpression()) {\n    return findParentForDelete(parent);\n  }\n\n  if (parent.isCallExpression()) {\n    return findParentForDelete(parent);\n  }\n\n  if (parent.isForInStatement({ left: path.node })) {\n    return findParentForDelete(parent);\n  }\n\n  if (\n    parent.isFunctionExpression({ body: path.node }) ||\n    parent.isObjectMethod() ||\n    parent.isClassMethod()\n  ) {\n    return findParentForDelete(parent);\n  }\n\n  if (parent.isBlockStatement()) {\n    const body = parent.get('body');\n    if (body.length === 1) {\n      return findParentForDelete(parent);\n    }\n\n    if (path.listKey === 'body' && typeof path.key === 'number') {\n      if (path.key > 0) {\n        // We can check whether the previous one can be removed\n        const prevStatement = body[path.key - 1];\n        if (\n          prevStatement.isIfStatement() &&\n          prevStatement.get('consequent').isReturnStatement()\n        ) {\n          // It's `if (…) return …`, we can remove it.\n          return findParentForDelete(prevStatement);\n        }\n      } else if (\n        body.slice(1).every((statement) => deletingNodes.has(statement))\n      ) {\n        // If it is the first statement and all other statements\n        // are marked for deletion, we can remove the whole block.\n        return findParentForDelete(parent);\n      }\n    }\n  }\n\n  if (parent.isVariableDeclarator()) {\n    return findParentForDelete(parent);\n  }\n\n  if (\n    parent.isExportNamedDeclaration() &&\n    ((parent.node.specifiers.length === 1 &&\n      parent.node.specifiers[0] === path.node) ||\n      parent.node.declaration === path.node)\n  ) {\n    return findParentForDelete(parent);\n  }\n\n  if (parent.isExportDefaultDeclaration()) {\n    return findParentForDelete(parent);\n  }\n\n  if (parent.isTryStatement()) {\n    return findParentForDelete(parent);\n  }\n\n  if (parent.isExportSpecifier()) {\n    return findParentForDelete(parent);\n  }\n\n  if (parent.isConditionalExpression()) {\n    return findParentForDelete(parent);\n  }\n\n  for (const key of ['body', 'declarations', 'specifiers']) {\n    if (path.listKey === key && typeof path.key === 'number') {\n      const list = parent.get(key) as NodePath[];\n      if (list.length === 1) {\n        return findParentForDelete(parent);\n      }\n    }\n  }\n\n  for (const key of [\n    'argument',\n    'block',\n    'body',\n    'callee',\n    'discriminant',\n    'expression',\n    'id',\n    'left',\n    'object',\n    'property',\n    'right',\n    'test',\n  ]) {\n    if (path.key === key && parent.get(key) === path) {\n      return findParentForDelete(parent);\n    }\n  }\n\n  return path;\n}\n\n// @babel/preset-typescript transpiles enums, but doesn't reference used identifiers.\nfunction referenceEnums(program: NodePath<Program>) {\n  /*\n   * We are looking for transpiled enums.\n   *   (function (Colors) {\n   *     Colors[\"BLUE\"] = \"#27509A\";\n   *   })(Colors || (Colors = {}));\n   */\n  program.traverse({\n    ExpressionStatement(expressionStatement) {\n      const expression = expressionStatement.get('expression');\n      if (!expression.isCallExpression()) return;\n\n      const callee = expression.get('callee');\n      const args = expression.get('arguments');\n      if (!callee.isFunctionExpression() || args.length !== 1) return;\n      const [arg] = args;\n      if (arg.isLogicalExpression({ operator: '||' })) {\n        referenceAll(arg);\n      }\n    },\n  });\n}\n\nconst fixed = new WeakSet<NodePath<Program>>();\n\nfunction removeUnreferenced(items: NodePath<Identifier | JSXIdentifier>[]) {\n  const referenced = new Set<NodePath<Identifier | JSXIdentifier>>();\n  items.forEach((item) => {\n    if (!item.node || isRemoved(item)) return;\n    const binding = item.scope.getBinding(item.node.name);\n    if (!binding) return;\n    const hasReferences =\n      binding.referencePaths.filter((i) => !isRemoved(i)).length > 0;\n    if (hasReferences) {\n      referenced.add(item);\n      return;\n    }\n\n    const forDeleting = [binding.path, ...binding.constantViolations]\n      .map((i) => findParentForDelete(i))\n      .filter(isNotNull);\n\n    if (forDeleting.length === 0) return;\n\n    findIdentifiers(forDeleting).forEach((identifier) => {\n      referenced.add(identifier);\n    });\n\n    removeWithRelated(forDeleting);\n  });\n\n  const result = [...referenced];\n  result.sort((a, b) => a.node?.name.localeCompare(b.node?.name));\n\n  return result;\n}\n\nfunction removeWithRelated(paths: NodePath[]) {\n  if (paths.length === 0) return;\n\n  const rootPath = paths[0].scope.getProgramParent().path as NodePath<Program>;\n\n  if (!fixed.has(rootPath)) {\n    // Some libraries don't care about bindings, references, and other staff\n    // So we have to fix the scope before we can detect unused code\n    referenceEnums(rootPath);\n    fixed.add(rootPath);\n  }\n\n  let clean = false;\n  let referencedIdentifiers: NodePath<Identifier | JSXIdentifier>[] = [];\n  const declared: Binding[] = [];\n\n  paths.forEach((path) => {\n    const deletingPath = findParentForDelete(path);\n    if (!deletingPath) return;\n\n    referencedIdentifiers.push(\n      ...findIdentifiers([deletingPath], 'referenced')\n    );\n    declared.push(\n      ...findIdentifiers([deletingPath], 'binding').map(\n        (i) => i.scope.getBinding(i.node.name)!\n      )\n    );\n\n    mutate(deletingPath, (p) => {\n      if (!isRemoved(p)) p.remove();\n    });\n  });\n\n  if (declared.length > 0) {\n    removeWithRelated(\n      declared.reduce(\n        (acc, i) => [...acc, ...i.referencePaths.filter(nonType)],\n        [] as NodePath[]\n      )\n    );\n  }\n\n  referencedIdentifiers.sort((a, b) =>\n    a.node?.name.localeCompare(b.node?.name)\n  );\n\n  while (!clean && referencedIdentifiers.length > 0) {\n    const referenced = removeUnreferenced(referencedIdentifiers);\n    clean =\n      referenced.map((i) => i.node?.name).join('|') ===\n      referencedIdentifiers.map((i) => i.node?.name).join('|');\n    referencedIdentifiers = referenced;\n  }\n}\n\nfunction mutate<T extends NodePath>(path: T, fn: (p: T) => NodePath[] | void) {\n  const dereferenced = dereferenceAll(path);\n\n  const mutated = fn(path);\n\n  referenceAll(path);\n  mutated?.forEach((p) => referenceAll(p));\n\n  const dead = dereferenced.filter((p) => !isReferenced(p));\n\n  const forDeleting: NodePath[] = [];\n  dead.forEach((binding) => {\n    const assignments = [binding.path, ...binding.constantViolations];\n    assignments.forEach((assignment) => {\n      const { scope } = assignment;\n      const declared = Object.values(\n        assignment.getOuterBindingIdentifiers(false)\n      );\n      if (\n        declared.length === 1 &&\n        'name' in declared[0] &&\n        declared[0].name === binding.identifier.name\n      ) {\n        // Only one identifier is declared, so we can remove the whole declaration\n        forDeleting.push(assignment);\n        return;\n      }\n\n      if (\n        declared.every(\n          (identifier) =>\n            identifier.type === 'Identifier' &&\n            !scope.getBinding(identifier.name)?.referenced\n        )\n      ) {\n        // No other identifier is referenced, so we can remove the whole declaration\n        forDeleting.push(assignment);\n        return;\n      }\n\n      // We can't remove the binding, but we can remove the part of it\n      assignment.traverse({\n        Identifier(identifier) {\n          if (identifier.node.name === binding.identifier.name) {\n            const parent = identifier.parentPath;\n            if (\n              parent.isArrayPattern() &&\n              identifier.listKey === 'elements' &&\n              typeof identifier.key === 'number'\n            ) {\n              parent.node.elements[identifier.key] = null;\n            } else if (parent.isObjectProperty()) {\n              forDeleting.push(parent);\n            }\n          }\n        },\n      });\n    });\n  });\n\n  removeWithRelated(forDeleting);\n}\n\nexport { mutate, removeWithRelated };\n"],"mappings":"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"}