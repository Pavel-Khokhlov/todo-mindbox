{"version":3,"file":"collectExportsAndImports.js","names":["warn","isExports","isNotNull","isRequire","isTypedNode","sideEffectImport","item","imported","explicitImport","getValue","node","type","name","value","isType","p","importKind","exportKind","collectors","ImportSpecifier","path","source","get","local","ImportDefaultSpecifier","ImportNamespaceSpecifier","unfoldNamespaceImport","collectFromImportDeclaration","state","specifiers","length","imports","push","forEach","specifier","isImportSpecifier","collector","getAncestorsWhile","cond","result","current","parentPath","whatIsDestructed","objectPattern","destructedProps","traverse","Identifier","identifier","isBindingIdentifier","parent","isObjectProperty","chain","filter","map","key","isIdentifier","reverse","what","as","isRestElement","argument","importFromVariableDeclarator","isSync","id","isObjectPattern","exportFromVariableDeclarator","init","isExpression","exported","destructed","collectFromDynamicImport","callExpression","isCallExpression","sourcePath","isStringLiteral","container","isAwaited","isAwaitExpression","isVariableDeclarator","prop","getImportTypeByInteropFunction","callee","undefined","startsWith","collectFromRequire","variableDeclarator","unfolded","isMemberExpression","property","isExpressionStatement","isChainOfVoidAssignment","right","isUnaryExpression","operator","isAssignmentExpression","getGetterValueFromDescriptor","descriptor","getter","find","isFunctionExpression","returnStatement","isReturnStatement","collectFromExports","object","memberExpression","exportName","saveRef","exportRefs","has","set","assignmentExpression","left","exports","matchesPattern","obj","isObjectExpression","collectFromRequireOrExports","importItem","binding","scope","getBinding","referenced","referencePath","referencePaths","ancestor","isTSType","isFlowType","computed","isExportSpecifier","collectFromExportAllDeclaration","reexports","collectFromExportSpecifier","isExportDefaultSpecifier","isExportNamespaceSpecifier","collectFromExportNamedDeclaration","declaration","isVariableDeclaration","declarator","isFunctionDeclaration","collectFromExportDefaultDeclaration","cache","WeakMap","collectFromAssignmentExpression","skip","collectFromCallExpression","maybeExportStart","requireCall","collectExportsAndImports","filename","force","Map","AssignmentExpression","CallExpression","ExportAllDeclaration","ExportDefaultDeclaration","ExportNamedDeclaration","ImportDeclaration","Import"],"sources":["../src/collectExportsAndImports.ts"],"sourcesContent":["/* eslint @typescript-eslint/no-use-before-define: [\"error\", { \"functions\": false }] */\n/* eslint-disable no-restricted-syntax,no-continue */\n\nimport type { NodePath } from '@babel/traverse';\nimport type {\n  CallExpression,\n  ExportDefaultDeclaration,\n  ExportNamedDeclaration,\n  ExportSpecifier,\n  Identifier,\n  Import,\n  ImportDeclaration,\n  ImportDefaultSpecifier,\n  ImportNamespaceSpecifier,\n  ImportSpecifier,\n  MemberExpression,\n  ObjectPattern,\n  StringLiteral,\n  VariableDeclarator,\n  ExportDefaultSpecifier,\n  ExportNamespaceSpecifier,\n  AssignmentExpression,\n  ExportAllDeclaration,\n  ObjectExpression,\n  Expression,\n} from '@babel/types';\n\nimport { warn } from '@linaria/logger';\n\nimport isExports from './isExports';\nimport isNotNull from './isNotNull';\nimport isRequire from './isRequire';\nimport isTypedNode from './isTypedNode';\n\nexport interface ISideEffectImport {\n  imported: null;\n  local: NodePath;\n  source: string;\n}\n\nexport interface IImport {\n  imported: string | 'default' | '*';\n  local: NodePath<Identifier | MemberExpression>;\n  source: string;\n}\n\nexport interface IExport {\n  exported: string | 'default' | '*'; // '*' means re-export all\n  local: NodePath;\n}\n\nexport interface IReexport {\n  exported: string | 'default' | '*';\n  imported: string | 'default' | '*';\n  local: NodePath;\n  source: string;\n}\n\nexport interface IState {\n  exportRefs: Map<string, NodePath<MemberExpression>[]>;\n  exports: IExport[];\n  filename: string | null | undefined;\n  imports: (IImport | ISideEffectImport)[];\n  reexports: IReexport[];\n}\n\nexport const sideEffectImport = (\n  item: IImport | ISideEffectImport\n): item is ISideEffectImport => item.imported === null;\n\nexport const explicitImport = (\n  item: IImport | ISideEffectImport\n): item is IImport => item.imported !== null;\n\nfunction getValue({ node }: { node: Identifier | StringLiteral }): string {\n  return node.type === 'Identifier' ? node.name : node.value;\n}\n\n// We ignore imports and exports of types\nconst isType = (p: {\n  node: { importKind?: 'type' | unknown } | { exportKind?: 'type' | unknown };\n}): boolean =>\n  ('importKind' in p.node && p.node.importKind === 'type') ||\n  ('exportKind' in p.node && p.node.exportKind === 'type');\n\n// Force TypeScript to check, that we have implementation for every possible specifier\ntype SpecifierTypes = ImportDeclaration['specifiers'][number];\nconst collectors: {\n  [K in SpecifierTypes['type']]: (\n    path: NodePath<SpecifierTypes & { type: K }>,\n    source: string\n  ) => IImport[];\n} = {\n  ImportSpecifier(path: NodePath<ImportSpecifier>, source): IImport[] {\n    if (isType(path)) return [];\n    const imported = getValue(path.get('imported'));\n    const local = path.get('local');\n    return [{ imported, local, source }];\n  },\n\n  ImportDefaultSpecifier(\n    path: NodePath<ImportDefaultSpecifier>,\n    source\n  ): IImport[] {\n    const local = path.get('local');\n    return [{ imported: 'default', local, source }];\n  },\n\n  ImportNamespaceSpecifier(\n    path: NodePath<ImportNamespaceSpecifier>,\n    source\n  ): IImport[] {\n    const local = path.get('local');\n    return unfoldNamespaceImport({ imported: '*', local, source });\n  },\n};\n\nfunction collectFromImportDeclaration(\n  path: NodePath<ImportDeclaration>,\n  state: IState\n): void {\n  // If importKind is specified, and it's not a value, ignore that import\n  if (isType(path)) return;\n\n  const source = getValue(path.get('source'));\n  const specifiers = path.get('specifiers');\n\n  if (specifiers.length === 0) {\n    state.imports.push({ imported: null, local: path, source });\n  }\n\n  specifiers.forEach(<T extends SpecifierTypes>(specifier: NodePath<T>) => {\n    if (specifier.isImportSpecifier() && isType(specifier)) return;\n\n    const collector = collectors[\n      specifier.node.type\n    ] as typeof collectors[T['type']];\n\n    state.imports.push(...collector(specifier, source));\n  });\n}\n\ninterface IDestructed {\n  what: string | '*';\n  as: NodePath<Identifier>;\n}\n\nfunction getAncestorsWhile(path: NodePath, cond: (p: NodePath) => boolean) {\n  const result: NodePath[] = [];\n  let current: NodePath | null = path;\n  while (current && cond(current)) {\n    result.push(current);\n    current = current.parentPath;\n  }\n\n  return result;\n}\n\nfunction whatIsDestructed(\n  objectPattern: NodePath<ObjectPattern>\n): IDestructed[] {\n  const destructedProps: IDestructed[] = [];\n  objectPattern.traverse({\n    Identifier(identifier) {\n      if (identifier.isBindingIdentifier()) {\n        const parent = identifier.parentPath;\n        if (parent.isObjectProperty({ value: identifier.node })) {\n          const chain = getAncestorsWhile(parent, (p) => p !== objectPattern)\n            .filter(isTypedNode('ObjectProperty'))\n            .map((p) => {\n              const key = p.get('key');\n              if (!key.isIdentifier()) {\n                // TODO: try to process other type of keys or at least warn about this\n                return null;\n              }\n\n              return key;\n            })\n            .filter(isNotNull);\n          chain.reverse();\n\n          if (chain.length > 0) {\n            destructedProps.push({\n              what: chain[0].node.name,\n              as: identifier,\n            });\n          }\n\n          return;\n        }\n\n        if (parent.isRestElement({ argument: identifier.node })) {\n          destructedProps.push({\n            what: '*',\n            as: identifier,\n          });\n        }\n      }\n    },\n  });\n\n  return destructedProps;\n}\n\nfunction importFromVariableDeclarator(\n  path: NodePath<VariableDeclarator>,\n  isSync: boolean\n): IDestructed[] {\n  const id = path.get('id');\n  if (id.isIdentifier()) {\n    // It's the simplest case when the full namespace is imported\n    return [\n      {\n        as: id,\n        what: '*',\n      },\n    ];\n  }\n\n  if (!isSync) {\n    // Something went wrong\n    // Is it something like `const { … } = import(…)`?\n    warn('evaluator:collectExportsAndImports', '`import` should be awaited');\n    return [];\n  }\n\n  if (id.isObjectPattern()) {\n    return whatIsDestructed(id);\n  }\n\n  // What else it can be?\n  warn(\n    'evaluator:collectExportsAndImports:importFromVariableDeclarator',\n    'Unknown type of id',\n    id.node.type\n  );\n\n  return [];\n}\n\nfunction exportFromVariableDeclarator(\n  path: NodePath<VariableDeclarator>\n): IExport[] {\n  const id = path.get('id');\n  const init = path.get('init');\n\n  // If there is no init expression, we can ignore this export\n  if (!init || !init.isExpression()) return [];\n\n  if (id.isIdentifier()) {\n    // It is `export const a = 1;`\n    return [\n      {\n        local: init,\n        exported: id.node.name,\n      },\n    ];\n  }\n\n  if (id.isObjectPattern()) {\n    // It is `export const { a, ...rest } = obj;`\n    return whatIsDestructed(id).map((destructed) => ({\n      local: init,\n      exported: destructed.as.node.name,\n    }));\n  }\n\n  // What else it can be?\n  warn(\n    'evaluator:collectExportsAndImports:exportFromVariableDeclarator',\n    'Unknown type of id',\n    id.node.type\n  );\n\n  return [];\n}\n\nfunction collectFromDynamicImport(path: NodePath<Import>, state: IState): void {\n  const { parentPath: callExpression } = path;\n  if (!callExpression.isCallExpression()) {\n    // It's wrong `import`\n    return;\n  }\n\n  const [sourcePath] = callExpression.get('arguments');\n  if (!sourcePath || !sourcePath.isStringLiteral()) {\n    // Import should have at least one argument, and it should be StringLiteral\n    return;\n  }\n\n  const source = sourcePath.node.value;\n\n  let { parentPath: container, key } = callExpression;\n  let isAwaited = false;\n\n  if (container.isAwaitExpression()) {\n    // If it's not awaited import, it imports the full namespace\n    isAwaited = true;\n    key = container.key;\n    container = container.parentPath!;\n  }\n\n  // Is it `const something = await import(\"something\")`?\n  if (key === 'init' && container.isVariableDeclarator()) {\n    importFromVariableDeclarator(container, isAwaited).map((prop) =>\n      state.imports.push({ imported: prop.what, local: prop.as, source })\n    );\n  }\n}\n\nfunction getImportTypeByInteropFunction(\n  path: NodePath<CallExpression>\n): '*' | 'default' | undefined {\n  const callee = path.get('callee');\n  if (!callee.isIdentifier()) {\n    return undefined;\n  }\n\n  const { name } = callee.node;\n  if (\n    name.startsWith('_interopRequireDefault') ||\n    name.startsWith('__importDefault')\n  ) {\n    return 'default';\n  }\n\n  if (\n    name.startsWith('_interopRequireWildcard') ||\n    name.startsWith('__importStar')\n  ) {\n    return '*';\n  }\n\n  if (name.startsWith('__rest')) {\n    return '*';\n  }\n\n  return undefined;\n}\n\nfunction collectFromRequire(path: NodePath<Identifier>, state: IState): void {\n  if (!isRequire(path)) return;\n\n  const { parentPath: callExpression } = path;\n  if (!callExpression.isCallExpression()) {\n    // It's wrong `require`\n    return;\n  }\n\n  const [sourcePath] = callExpression.get('arguments');\n  if (!sourcePath || !sourcePath.isStringLiteral()) {\n    // Import should have at least one argument, and it should be StringLiteral\n    return;\n  }\n\n  const source = sourcePath.node.value;\n\n  const { parentPath: container, key } = callExpression;\n\n  if (container.isCallExpression() && key === 0) {\n    // It may be transpiled import such as\n    // `var _atomic = _interopRequireDefault(require(\"@linaria/atomic\"));`\n    const imported = getImportTypeByInteropFunction(container);\n    if (!imported) {\n      // It's not a transpiled import.\n      // TODO: Can we guess that it's a namespace import?\n      warn(\n        'evaluator:collectExportsAndImports',\n        'Unknown wrapper of require',\n        container.node.callee\n      );\n      return;\n    }\n\n    const { parentPath: variableDeclarator } = container;\n    if (!variableDeclarator.isVariableDeclarator()) {\n      // TODO: Where else it can be?\n      warn(\n        'evaluator:collectExportsAndImports',\n        'Unexpected require inside',\n        variableDeclarator.node.type\n      );\n      return;\n    }\n\n    const id = variableDeclarator.get('id');\n    if (!id.isIdentifier()) {\n      warn(\n        'evaluator:collectExportsAndImports',\n        'Id should be Identifier',\n        variableDeclarator.node.type\n      );\n      return;\n    }\n\n    if (imported === '*') {\n      const unfolded = unfoldNamespaceImport({\n        imported,\n        local: id,\n        source,\n      });\n      state.imports.push(...unfolded);\n    } else {\n      state.imports.push({\n        imported,\n        local: id,\n        source,\n      });\n    }\n  }\n\n  if (container.isMemberExpression()) {\n    // It is `require('@linaria/shaker').dep`\n    const property = container.get('property');\n    if (!property.isIdentifier() && !property.isStringLiteral()) {\n      warn(\n        'evaluator:collectExportsAndImports',\n        'Property should be Identifier or StringLiteral',\n        property.node.type\n      );\n\n      return;\n    }\n\n    const { parentPath: variableDeclarator } = container;\n\n    if (variableDeclarator.isVariableDeclarator()) {\n      // It is `const … = require('@linaria/shaker').dep`;\n      const id = variableDeclarator.get('id');\n      if (id.isIdentifier()) {\n        state.imports.push({\n          imported: getValue(property),\n          local: id,\n          source,\n        });\n      } else {\n        warn(\n          'evaluator:collectExportsAndImports',\n          'Id should be Identifier',\n          variableDeclarator.node.type\n        );\n      }\n    } else {\n      // Maybe require is passed as an argument to some function?\n      // Just use the whole MemberExpression as a local\n      state.imports.push({\n        imported: getValue(property),\n        local: container,\n        source,\n      });\n    }\n\n    return;\n  }\n\n  // Is it `const something = require(\"something\")`?\n  if (key === 'init' && container.isVariableDeclarator()) {\n    importFromVariableDeclarator(container, true).forEach((prop) => {\n      if (prop.what === '*') {\n        const unfolded = unfoldNamespaceImport({\n          imported: '*',\n          local: prop.as,\n          source,\n        });\n\n        state.imports.push(...unfolded);\n      } else {\n        state.imports.push({\n          imported: prop.what,\n          local: prop.as,\n          source,\n        });\n      }\n    });\n  }\n\n  if (container.isExpressionStatement()) {\n    // Looks like standalone require\n    state.imports.push({\n      imported: null,\n      local: container,\n      source,\n    });\n  }\n}\n\nfunction isChainOfVoidAssignment(\n  path: NodePath<AssignmentExpression>\n): boolean {\n  const right = path.get('right');\n  if (right.isUnaryExpression({ operator: 'void' })) {\n    return true;\n  }\n\n  if (right.isAssignmentExpression()) {\n    return isChainOfVoidAssignment(right);\n  }\n\n  return false;\n}\n\nfunction getGetterValueFromDescriptor(\n  descriptor: NodePath<ObjectExpression>\n): NodePath<Expression> | undefined {\n  const getter = descriptor\n    .get('properties')\n    .filter(isTypedNode('ObjectProperty'))\n    .find((p) => p.get('key').isIdentifier({ name: 'get' }));\n  const value = getter?.get('value');\n  if (value?.isFunctionExpression()) {\n    const returnStatement = value.get('body').get('body')[0];\n    if (returnStatement?.isReturnStatement()) {\n      const local = returnStatement.get('argument');\n      if (local.isExpression()) {\n        return local;\n      }\n    }\n  }\n\n  return undefined;\n}\n\nfunction collectFromExports(path: NodePath<Identifier>, state: IState): void {\n  if (!isExports(path)) return;\n\n  if (path.parentPath.isMemberExpression({ object: path.node })) {\n    // It is `exports.prop = …`\n    const memberExpression = path.parentPath;\n    const property = memberExpression.get('property');\n    if (!property.isIdentifier()) {\n      return;\n    }\n\n    const exportName = property.node.name;\n\n    const saveRef = () => {\n      // Save all export.____ usages for later\n      if (!state.exportRefs.has(exportName)) {\n        state.exportRefs.set(exportName, []);\n      }\n\n      state.exportRefs.get(exportName)!.push(memberExpression);\n    };\n\n    const assignmentExpression = memberExpression.parentPath;\n\n    if (\n      !assignmentExpression.isAssignmentExpression({\n        left: memberExpression.node,\n      })\n    ) {\n      // If it's not `exports.prop = …`. Just save it.\n      saveRef();\n      return;\n    }\n\n    const right = assignmentExpression.get('right');\n\n    if (isChainOfVoidAssignment(assignmentExpression)) {\n      // It is `exports.foo = void 0`\n      return;\n    }\n\n    const { name } = property.node;\n    if (name === '__esModule') {\n      return;\n    }\n\n    saveRef();\n    state.exports.push({ exported: property.node.name, local: right });\n\n    return;\n  }\n\n  if (\n    path.parentPath.isCallExpression() &&\n    path.parentPath.get('callee').matchesPattern('Object.defineProperty')\n  ) {\n    const [obj, prop, descriptor] = path.parentPath.get('arguments');\n    if (\n      obj?.isIdentifier(path.node) &&\n      prop?.isStringLiteral() &&\n      prop.node.value !== '__esModule' &&\n      descriptor?.isObjectExpression()\n    ) {\n      /**\n       *  Object.defineProperty(exports, \"token\", {\n       *    enumerable: true,\n       *    get: function get() {\n       *      return _unknownPackage.token;\n       *    }\n       *  });\n       */\n      const exported = prop.node.value;\n      const local = getGetterValueFromDescriptor(descriptor);\n      if (local) {\n        state.exports.push({ exported, local });\n      }\n    } else if (\n      obj?.isIdentifier(path.node) &&\n      prop?.isIdentifier() &&\n      descriptor?.isObjectExpression()\n    ) {\n      /**\n       *  Object.defineProperty(exports, key, {\n       *    enumerable: true,\n       *    get: function get() {\n       *      return _unknownPackage[key];\n       *    }\n       *  });\n       */\n      const local = getGetterValueFromDescriptor(descriptor);\n      if (local) {\n        state.exports.push({ exported: '*', local });\n      }\n    }\n  }\n}\n\nfunction collectFromRequireOrExports(\n  path: NodePath<Identifier>,\n  state: IState\n): void {\n  if (isRequire(path)) {\n    collectFromRequire(path, state);\n  } else if (isExports(path)) {\n    collectFromExports(path, state);\n  }\n}\n\nfunction unfoldNamespaceImport(\n  importItem: IImport & { imported: '*' }\n): IImport[] {\n  const result: IImport[] = [];\n  const { local } = importItem;\n  if (!local.isIdentifier()) {\n    // TODO: handle it\n    return [importItem];\n  }\n\n  const binding = local.scope.getBinding(local.node.name);\n  if (!binding?.referenced) {\n    // Imported namespace is not referenced and probably not used,\n    // but it can have side effects, so we should keep it as is\n    return [importItem];\n  }\n\n  for (const referencePath of binding?.referencePaths ?? []) {\n    if (\n      referencePath.find(\n        (ancestor) => ancestor.isTSType() || ancestor.isFlowType()\n      )\n    ) {\n      continue;\n    }\n\n    const { parentPath } = referencePath;\n    if (parentPath?.isMemberExpression() && referencePath.key === 'object') {\n      const property = parentPath.get('property');\n      const object = parentPath.get('object');\n      let imported: string | null;\n      if (parentPath.node.computed && property.isStringLiteral()) {\n        imported = property.node.value;\n      } else if (!parentPath.node.computed && property.isIdentifier()) {\n        imported = property.node.name;\n      } else {\n        imported = null;\n      }\n\n      if (object.isIdentifier() && imported) {\n        result.push({\n          ...importItem,\n          imported,\n          local: parentPath,\n        });\n      } else {\n        result.push(importItem);\n        break;\n      }\n\n      continue;\n    }\n\n    if (parentPath?.isVariableDeclarator() && referencePath.key === 'init') {\n      importFromVariableDeclarator(parentPath, true).map((prop) =>\n        result.push({ ...importItem, imported: prop.what, local: prop.as })\n      );\n\n      continue;\n    }\n\n    if (parentPath?.isExportSpecifier()) {\n      // The whole namespace is re-exported\n      result.push(importItem);\n      break;\n    }\n\n    // Otherwise, we can't predict usage and import it as is\n    // TODO: handle more cases\n    warn(\n      'evaluator:collectExportsAndImports:unfoldNamespaceImports',\n      'Unknown reference',\n      referencePath.node.type\n    );\n    result.push(importItem);\n    break;\n  }\n\n  return result;\n}\n\nfunction collectFromExportAllDeclaration(\n  path: NodePath<ExportAllDeclaration>,\n  state: IState\n): void {\n  if (isType(path)) return;\n  const source = path.get('source')?.node?.value;\n  if (!source) return;\n\n  // It is `export * from './css';`\n  state.reexports.push({\n    exported: '*',\n    imported: '*',\n    local: path,\n    source,\n  });\n}\n\nfunction collectFromExportSpecifier(\n  path: NodePath<\n    ExportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier\n  >,\n  source: string | undefined,\n  state: IState\n): void {\n  if (path.isExportSpecifier()) {\n    const exported = getValue(path.get('exported'));\n    if (source) {\n      // It is `export { foo } from './css';`\n      const imported = path.get('local').node.name;\n      state.reexports.push({\n        exported,\n        imported,\n        local: path,\n        source,\n      });\n    } else {\n      const local = path.get('local');\n      state.exports.push({ local, exported });\n    }\n\n    return;\n  }\n\n  if (path.isExportDefaultSpecifier() && source) {\n    // It is `export default from './css';`\n    state.reexports.push({\n      exported: 'default',\n      imported: 'default',\n      local: path,\n      source,\n    });\n  }\n\n  if (path.isExportNamespaceSpecifier() && source) {\n    const exported = path.get('exported').node.name;\n    // It is `export * as foo from './css';`\n    state.reexports.push({\n      exported,\n      imported: '*',\n      local: path,\n      source,\n    });\n  }\n\n  // TODO: handle other cases\n  warn(\n    'evaluator:collectExportsAndImports:collectFromExportSpecifier',\n    'Unprocessed ExportSpecifier',\n    path.node.type\n  );\n}\n\nfunction collectFromExportNamedDeclaration(\n  path: NodePath<ExportNamedDeclaration>,\n  state: IState\n): void {\n  if (isType(path)) return;\n\n  const source = path.get('source')?.node?.value;\n  const specifiers = path.get('specifiers');\n  if (specifiers) {\n    specifiers.forEach((specifier) =>\n      collectFromExportSpecifier(specifier, source, state)\n    );\n  }\n\n  const declaration = path.get('declaration');\n  if (declaration.isVariableDeclaration()) {\n    declaration.get('declarations').forEach((declarator) => {\n      exportFromVariableDeclarator(declarator).forEach((prop) => {\n        // What is defined\n        state.exports.push(prop);\n      });\n    });\n  }\n\n  if (declaration.isFunctionDeclaration()) {\n    const id = declaration.get('id');\n    if (id.isIdentifier()) {\n      state.exports.push({\n        exported: id.node.name,\n        local: id,\n      });\n    }\n  }\n}\n\nfunction collectFromExportDefaultDeclaration(\n  path: NodePath<ExportDefaultDeclaration>,\n  state: IState\n): void {\n  if (isType(path)) return;\n\n  const declaration = path.get('declaration');\n  state.exports.push({ exported: 'default', local: declaration });\n}\n\nconst cache = new WeakMap<NodePath, IState>();\n\nfunction collectFromAssignmentExpression(\n  path: NodePath<AssignmentExpression>,\n  state: IState\n): void {\n  const left = path.get('left');\n  const right = path.get('right');\n\n  let exported: IReexport['exported'] | undefined;\n\n  if (left.isMemberExpression() && isExports(left.get('object'))) {\n    const property = left.get('property');\n    if (property.isIdentifier()) {\n      exported = property.node.name;\n    }\n  } else if (isExports(left)) {\n    exported = '*'; // maybe\n  }\n\n  if (!exported) return;\n\n  if (!right.isCallExpression() || !isRequire(right.get('callee'))) return;\n\n  const sourcePath = right.get('arguments')?.[0];\n  const source = sourcePath.isStringLiteral()\n    ? sourcePath.node.value\n    : undefined;\n  if (!source) return;\n\n  // It is `exports.foo = require('./css');`\n\n  state.reexports.push({\n    exported,\n    imported: '*',\n    local: path,\n    source,\n  });\n\n  path.skip();\n}\n\nfunction collectFromCallExpression(\n  path: NodePath<CallExpression>,\n  state: IState\n) {\n  const maybeExportStart = path.get('callee');\n  if (\n    !maybeExportStart.isIdentifier() ||\n    !maybeExportStart.node.name.startsWith('__exportStar')\n  ) {\n    return;\n  }\n\n  const [requireCall, exports] = path.get('arguments');\n  if (!isExports(exports)) return;\n  if (!requireCall.isCallExpression()) return;\n  const callee = requireCall.get('callee');\n  const sourcePath = requireCall.get('arguments')?.[0];\n  if (!isRequire(callee) || !sourcePath.isStringLiteral()) return;\n\n  const source = sourcePath.node.value;\n  if (!source) return;\n\n  state.reexports.push({\n    exported: '*',\n    imported: '*',\n    local: path,\n    source,\n  });\n\n  path.skip();\n}\n\nexport default function collectExportsAndImports(\n  path: NodePath,\n  filename: string | null | undefined,\n  force = false\n): IState {\n  const state: IState = {\n    exportRefs: new Map(),\n    exports: [],\n    filename,\n    imports: [],\n    reexports: [],\n  };\n\n  if (!force && cache.has(path)) {\n    return cache.get(path) ?? state;\n  }\n\n  path.traverse(\n    {\n      AssignmentExpression: collectFromAssignmentExpression,\n      CallExpression: collectFromCallExpression,\n      ExportAllDeclaration: collectFromExportAllDeclaration,\n      ExportDefaultDeclaration: collectFromExportDefaultDeclaration,\n      ExportNamedDeclaration: collectFromExportNamedDeclaration,\n      ImportDeclaration: collectFromImportDeclaration,\n      Import: collectFromDynamicImport,\n      Identifier: collectFromRequireOrExports,\n    },\n    state\n  );\n\n  cache.set(path, state);\n\n  return state;\n}\n"],"mappings":"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"}