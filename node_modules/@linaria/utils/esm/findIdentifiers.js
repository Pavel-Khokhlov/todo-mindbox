const checkers = {
  binding: ex => ex.isBindingIdentifier(),
  both: ex => ex.isBindingIdentifier() || ex.isReferencedIdentifier(),
  referenced: ex => ex.isReferencedIdentifier()
};
export function nonType(path) {
  return !path.find(p => p.isTSTypeReference() || p.isTSTypeQuery() || p.isFlowType() || p.isFlowDeclaration());
}
export default function findIdentifiers(expressions, type = 'referenced') {
  const identifiers = [];
  expressions.forEach(ex => {
    const emit = path => {
      if (!path.node || path.removed || !checkers[type](path)) {
        return;
      }

      if (!nonType(path)) {
        // If skip in TSTypeAnnotation visitor doesn't work
        return;
      } // TODO: Is there a better way to check that it's a local variable?


      const binding = path.scope.getBinding(path.node.name);

      if (!binding) {
        return;
      }

      if (type === 'referenced' && ex.isAncestor(binding.path)) {
        // This identifier is declared inside the expression. We don't need it.
        return;
      }

      identifiers.push(path);
    };

    if (ex.isIdentifier() || ex.isJSXIdentifier()) {
      emit(ex);
    } else {
      ex.traverse({
        TSTypeAnnotation(path) {
          // We ignore identifiers in type annotations
          // It will produce broken TS code, but we don't care
          path.skip();
        },

        Identifier(path) {
          emit(path);
        },

        JSXIdentifier(path) {
          emit(path);
        }

      });
    }
  });
  return identifiers;
}
//# sourceMappingURL=findIdentifiers.js.map