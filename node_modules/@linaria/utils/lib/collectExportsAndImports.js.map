{"version":3,"file":"collectExportsAndImports.js","names":["sideEffectImport","item","imported","explicitImport","getValue","node","type","name","value","isType","p","importKind","exportKind","collectors","ImportSpecifier","path","source","get","local","ImportDefaultSpecifier","ImportNamespaceSpecifier","unfoldNamespaceImport","collectFromImportDeclaration","state","specifiers","length","imports","push","forEach","specifier","isImportSpecifier","collector","getAncestorsWhile","cond","result","current","parentPath","whatIsDestructed","objectPattern","destructedProps","traverse","Identifier","identifier","isBindingIdentifier","parent","isObjectProperty","chain","filter","isTypedNode","map","key","isIdentifier","isNotNull","reverse","what","as","isRestElement","argument","importFromVariableDeclarator","isSync","id","warn","isObjectPattern","exportFromVariableDeclarator","init","isExpression","exported","destructed","collectFromDynamicImport","callExpression","isCallExpression","sourcePath","isStringLiteral","container","isAwaited","isAwaitExpression","isVariableDeclarator","prop","getImportTypeByInteropFunction","callee","undefined","startsWith","collectFromRequire","isRequire","variableDeclarator","unfolded","isMemberExpression","property","isExpressionStatement","isChainOfVoidAssignment","right","isUnaryExpression","operator","isAssignmentExpression","getGetterValueFromDescriptor","descriptor","getter","find","isFunctionExpression","returnStatement","isReturnStatement","collectFromExports","isExports","object","memberExpression","exportName","saveRef","exportRefs","has","set","assignmentExpression","left","exports","matchesPattern","obj","isObjectExpression","collectFromRequireOrExports","importItem","binding","scope","getBinding","referenced","referencePath","referencePaths","ancestor","isTSType","isFlowType","computed","isExportSpecifier","collectFromExportAllDeclaration","reexports","collectFromExportSpecifier","isExportDefaultSpecifier","isExportNamespaceSpecifier","collectFromExportNamedDeclaration","declaration","isVariableDeclaration","declarator","isFunctionDeclaration","collectFromExportDefaultDeclaration","cache","WeakMap","collectFromAssignmentExpression","skip","collectFromCallExpression","maybeExportStart","requireCall","collectExportsAndImports","filename","force","Map","AssignmentExpression","CallExpression","ExportAllDeclaration","ExportDefaultDeclaration","ExportNamedDeclaration","ImportDeclaration","Import"],"sources":["../src/collectExportsAndImports.ts"],"sourcesContent":["/* eslint @typescript-eslint/no-use-before-define: [\"error\", { \"functions\": false }] */\n/* eslint-disable no-restricted-syntax,no-continue */\n\nimport type { NodePath } from '@babel/traverse';\nimport type {\n  CallExpression,\n  ExportDefaultDeclaration,\n  ExportNamedDeclaration,\n  ExportSpecifier,\n  Identifier,\n  Import,\n  ImportDeclaration,\n  ImportDefaultSpecifier,\n  ImportNamespaceSpecifier,\n  ImportSpecifier,\n  MemberExpression,\n  ObjectPattern,\n  StringLiteral,\n  VariableDeclarator,\n  ExportDefaultSpecifier,\n  ExportNamespaceSpecifier,\n  AssignmentExpression,\n  ExportAllDeclaration,\n  ObjectExpression,\n  Expression,\n} from '@babel/types';\n\nimport { warn } from '@linaria/logger';\n\nimport isExports from './isExports';\nimport isNotNull from './isNotNull';\nimport isRequire from './isRequire';\nimport isTypedNode from './isTypedNode';\n\nexport interface ISideEffectImport {\n  imported: null;\n  local: NodePath;\n  source: string;\n}\n\nexport interface IImport {\n  imported: string | 'default' | '*';\n  local: NodePath<Identifier | MemberExpression>;\n  source: string;\n}\n\nexport interface IExport {\n  exported: string | 'default' | '*'; // '*' means re-export all\n  local: NodePath;\n}\n\nexport interface IReexport {\n  exported: string | 'default' | '*';\n  imported: string | 'default' | '*';\n  local: NodePath;\n  source: string;\n}\n\nexport interface IState {\n  exportRefs: Map<string, NodePath<MemberExpression>[]>;\n  exports: IExport[];\n  filename: string | null | undefined;\n  imports: (IImport | ISideEffectImport)[];\n  reexports: IReexport[];\n}\n\nexport const sideEffectImport = (\n  item: IImport | ISideEffectImport\n): item is ISideEffectImport => item.imported === null;\n\nexport const explicitImport = (\n  item: IImport | ISideEffectImport\n): item is IImport => item.imported !== null;\n\nfunction getValue({ node }: { node: Identifier | StringLiteral }): string {\n  return node.type === 'Identifier' ? node.name : node.value;\n}\n\n// We ignore imports and exports of types\nconst isType = (p: {\n  node: { importKind?: 'type' | unknown } | { exportKind?: 'type' | unknown };\n}): boolean =>\n  ('importKind' in p.node && p.node.importKind === 'type') ||\n  ('exportKind' in p.node && p.node.exportKind === 'type');\n\n// Force TypeScript to check, that we have implementation for every possible specifier\ntype SpecifierTypes = ImportDeclaration['specifiers'][number];\nconst collectors: {\n  [K in SpecifierTypes['type']]: (\n    path: NodePath<SpecifierTypes & { type: K }>,\n    source: string\n  ) => IImport[];\n} = {\n  ImportSpecifier(path: NodePath<ImportSpecifier>, source): IImport[] {\n    if (isType(path)) return [];\n    const imported = getValue(path.get('imported'));\n    const local = path.get('local');\n    return [{ imported, local, source }];\n  },\n\n  ImportDefaultSpecifier(\n    path: NodePath<ImportDefaultSpecifier>,\n    source\n  ): IImport[] {\n    const local = path.get('local');\n    return [{ imported: 'default', local, source }];\n  },\n\n  ImportNamespaceSpecifier(\n    path: NodePath<ImportNamespaceSpecifier>,\n    source\n  ): IImport[] {\n    const local = path.get('local');\n    return unfoldNamespaceImport({ imported: '*', local, source });\n  },\n};\n\nfunction collectFromImportDeclaration(\n  path: NodePath<ImportDeclaration>,\n  state: IState\n): void {\n  // If importKind is specified, and it's not a value, ignore that import\n  if (isType(path)) return;\n\n  const source = getValue(path.get('source'));\n  const specifiers = path.get('specifiers');\n\n  if (specifiers.length === 0) {\n    state.imports.push({ imported: null, local: path, source });\n  }\n\n  specifiers.forEach(<T extends SpecifierTypes>(specifier: NodePath<T>) => {\n    if (specifier.isImportSpecifier() && isType(specifier)) return;\n\n    const collector = collectors[\n      specifier.node.type\n    ] as typeof collectors[T['type']];\n\n    state.imports.push(...collector(specifier, source));\n  });\n}\n\ninterface IDestructed {\n  what: string | '*';\n  as: NodePath<Identifier>;\n}\n\nfunction getAncestorsWhile(path: NodePath, cond: (p: NodePath) => boolean) {\n  const result: NodePath[] = [];\n  let current: NodePath | null = path;\n  while (current && cond(current)) {\n    result.push(current);\n    current = current.parentPath;\n  }\n\n  return result;\n}\n\nfunction whatIsDestructed(\n  objectPattern: NodePath<ObjectPattern>\n): IDestructed[] {\n  const destructedProps: IDestructed[] = [];\n  objectPattern.traverse({\n    Identifier(identifier) {\n      if (identifier.isBindingIdentifier()) {\n        const parent = identifier.parentPath;\n        if (parent.isObjectProperty({ value: identifier.node })) {\n          const chain = getAncestorsWhile(parent, (p) => p !== objectPattern)\n            .filter(isTypedNode('ObjectProperty'))\n            .map((p) => {\n              const key = p.get('key');\n              if (!key.isIdentifier()) {\n                // TODO: try to process other type of keys or at least warn about this\n                return null;\n              }\n\n              return key;\n            })\n            .filter(isNotNull);\n          chain.reverse();\n\n          if (chain.length > 0) {\n            destructedProps.push({\n              what: chain[0].node.name,\n              as: identifier,\n            });\n          }\n\n          return;\n        }\n\n        if (parent.isRestElement({ argument: identifier.node })) {\n          destructedProps.push({\n            what: '*',\n            as: identifier,\n          });\n        }\n      }\n    },\n  });\n\n  return destructedProps;\n}\n\nfunction importFromVariableDeclarator(\n  path: NodePath<VariableDeclarator>,\n  isSync: boolean\n): IDestructed[] {\n  const id = path.get('id');\n  if (id.isIdentifier()) {\n    // It's the simplest case when the full namespace is imported\n    return [\n      {\n        as: id,\n        what: '*',\n      },\n    ];\n  }\n\n  if (!isSync) {\n    // Something went wrong\n    // Is it something like `const { … } = import(…)`?\n    warn('evaluator:collectExportsAndImports', '`import` should be awaited');\n    return [];\n  }\n\n  if (id.isObjectPattern()) {\n    return whatIsDestructed(id);\n  }\n\n  // What else it can be?\n  warn(\n    'evaluator:collectExportsAndImports:importFromVariableDeclarator',\n    'Unknown type of id',\n    id.node.type\n  );\n\n  return [];\n}\n\nfunction exportFromVariableDeclarator(\n  path: NodePath<VariableDeclarator>\n): IExport[] {\n  const id = path.get('id');\n  const init = path.get('init');\n\n  // If there is no init expression, we can ignore this export\n  if (!init || !init.isExpression()) return [];\n\n  if (id.isIdentifier()) {\n    // It is `export const a = 1;`\n    return [\n      {\n        local: init,\n        exported: id.node.name,\n      },\n    ];\n  }\n\n  if (id.isObjectPattern()) {\n    // It is `export const { a, ...rest } = obj;`\n    return whatIsDestructed(id).map((destructed) => ({\n      local: init,\n      exported: destructed.as.node.name,\n    }));\n  }\n\n  // What else it can be?\n  warn(\n    'evaluator:collectExportsAndImports:exportFromVariableDeclarator',\n    'Unknown type of id',\n    id.node.type\n  );\n\n  return [];\n}\n\nfunction collectFromDynamicImport(path: NodePath<Import>, state: IState): void {\n  const { parentPath: callExpression } = path;\n  if (!callExpression.isCallExpression()) {\n    // It's wrong `import`\n    return;\n  }\n\n  const [sourcePath] = callExpression.get('arguments');\n  if (!sourcePath || !sourcePath.isStringLiteral()) {\n    // Import should have at least one argument, and it should be StringLiteral\n    return;\n  }\n\n  const source = sourcePath.node.value;\n\n  let { parentPath: container, key } = callExpression;\n  let isAwaited = false;\n\n  if (container.isAwaitExpression()) {\n    // If it's not awaited import, it imports the full namespace\n    isAwaited = true;\n    key = container.key;\n    container = container.parentPath!;\n  }\n\n  // Is it `const something = await import(\"something\")`?\n  if (key === 'init' && container.isVariableDeclarator()) {\n    importFromVariableDeclarator(container, isAwaited).map((prop) =>\n      state.imports.push({ imported: prop.what, local: prop.as, source })\n    );\n  }\n}\n\nfunction getImportTypeByInteropFunction(\n  path: NodePath<CallExpression>\n): '*' | 'default' | undefined {\n  const callee = path.get('callee');\n  if (!callee.isIdentifier()) {\n    return undefined;\n  }\n\n  const { name } = callee.node;\n  if (\n    name.startsWith('_interopRequireDefault') ||\n    name.startsWith('__importDefault')\n  ) {\n    return 'default';\n  }\n\n  if (\n    name.startsWith('_interopRequireWildcard') ||\n    name.startsWith('__importStar')\n  ) {\n    return '*';\n  }\n\n  if (name.startsWith('__rest')) {\n    return '*';\n  }\n\n  return undefined;\n}\n\nfunction collectFromRequire(path: NodePath<Identifier>, state: IState): void {\n  if (!isRequire(path)) return;\n\n  const { parentPath: callExpression } = path;\n  if (!callExpression.isCallExpression()) {\n    // It's wrong `require`\n    return;\n  }\n\n  const [sourcePath] = callExpression.get('arguments');\n  if (!sourcePath || !sourcePath.isStringLiteral()) {\n    // Import should have at least one argument, and it should be StringLiteral\n    return;\n  }\n\n  const source = sourcePath.node.value;\n\n  const { parentPath: container, key } = callExpression;\n\n  if (container.isCallExpression() && key === 0) {\n    // It may be transpiled import such as\n    // `var _atomic = _interopRequireDefault(require(\"@linaria/atomic\"));`\n    const imported = getImportTypeByInteropFunction(container);\n    if (!imported) {\n      // It's not a transpiled import.\n      // TODO: Can we guess that it's a namespace import?\n      warn(\n        'evaluator:collectExportsAndImports',\n        'Unknown wrapper of require',\n        container.node.callee\n      );\n      return;\n    }\n\n    const { parentPath: variableDeclarator } = container;\n    if (!variableDeclarator.isVariableDeclarator()) {\n      // TODO: Where else it can be?\n      warn(\n        'evaluator:collectExportsAndImports',\n        'Unexpected require inside',\n        variableDeclarator.node.type\n      );\n      return;\n    }\n\n    const id = variableDeclarator.get('id');\n    if (!id.isIdentifier()) {\n      warn(\n        'evaluator:collectExportsAndImports',\n        'Id should be Identifier',\n        variableDeclarator.node.type\n      );\n      return;\n    }\n\n    if (imported === '*') {\n      const unfolded = unfoldNamespaceImport({\n        imported,\n        local: id,\n        source,\n      });\n      state.imports.push(...unfolded);\n    } else {\n      state.imports.push({\n        imported,\n        local: id,\n        source,\n      });\n    }\n  }\n\n  if (container.isMemberExpression()) {\n    // It is `require('@linaria/shaker').dep`\n    const property = container.get('property');\n    if (!property.isIdentifier() && !property.isStringLiteral()) {\n      warn(\n        'evaluator:collectExportsAndImports',\n        'Property should be Identifier or StringLiteral',\n        property.node.type\n      );\n\n      return;\n    }\n\n    const { parentPath: variableDeclarator } = container;\n\n    if (variableDeclarator.isVariableDeclarator()) {\n      // It is `const … = require('@linaria/shaker').dep`;\n      const id = variableDeclarator.get('id');\n      if (id.isIdentifier()) {\n        state.imports.push({\n          imported: getValue(property),\n          local: id,\n          source,\n        });\n      } else {\n        warn(\n          'evaluator:collectExportsAndImports',\n          'Id should be Identifier',\n          variableDeclarator.node.type\n        );\n      }\n    } else {\n      // Maybe require is passed as an argument to some function?\n      // Just use the whole MemberExpression as a local\n      state.imports.push({\n        imported: getValue(property),\n        local: container,\n        source,\n      });\n    }\n\n    return;\n  }\n\n  // Is it `const something = require(\"something\")`?\n  if (key === 'init' && container.isVariableDeclarator()) {\n    importFromVariableDeclarator(container, true).forEach((prop) => {\n      if (prop.what === '*') {\n        const unfolded = unfoldNamespaceImport({\n          imported: '*',\n          local: prop.as,\n          source,\n        });\n\n        state.imports.push(...unfolded);\n      } else {\n        state.imports.push({\n          imported: prop.what,\n          local: prop.as,\n          source,\n        });\n      }\n    });\n  }\n\n  if (container.isExpressionStatement()) {\n    // Looks like standalone require\n    state.imports.push({\n      imported: null,\n      local: container,\n      source,\n    });\n  }\n}\n\nfunction isChainOfVoidAssignment(\n  path: NodePath<AssignmentExpression>\n): boolean {\n  const right = path.get('right');\n  if (right.isUnaryExpression({ operator: 'void' })) {\n    return true;\n  }\n\n  if (right.isAssignmentExpression()) {\n    return isChainOfVoidAssignment(right);\n  }\n\n  return false;\n}\n\nfunction getGetterValueFromDescriptor(\n  descriptor: NodePath<ObjectExpression>\n): NodePath<Expression> | undefined {\n  const getter = descriptor\n    .get('properties')\n    .filter(isTypedNode('ObjectProperty'))\n    .find((p) => p.get('key').isIdentifier({ name: 'get' }));\n  const value = getter?.get('value');\n  if (value?.isFunctionExpression()) {\n    const returnStatement = value.get('body').get('body')[0];\n    if (returnStatement?.isReturnStatement()) {\n      const local = returnStatement.get('argument');\n      if (local.isExpression()) {\n        return local;\n      }\n    }\n  }\n\n  return undefined;\n}\n\nfunction collectFromExports(path: NodePath<Identifier>, state: IState): void {\n  if (!isExports(path)) return;\n\n  if (path.parentPath.isMemberExpression({ object: path.node })) {\n    // It is `exports.prop = …`\n    const memberExpression = path.parentPath;\n    const property = memberExpression.get('property');\n    if (!property.isIdentifier()) {\n      return;\n    }\n\n    const exportName = property.node.name;\n\n    const saveRef = () => {\n      // Save all export.____ usages for later\n      if (!state.exportRefs.has(exportName)) {\n        state.exportRefs.set(exportName, []);\n      }\n\n      state.exportRefs.get(exportName)!.push(memberExpression);\n    };\n\n    const assignmentExpression = memberExpression.parentPath;\n\n    if (\n      !assignmentExpression.isAssignmentExpression({\n        left: memberExpression.node,\n      })\n    ) {\n      // If it's not `exports.prop = …`. Just save it.\n      saveRef();\n      return;\n    }\n\n    const right = assignmentExpression.get('right');\n\n    if (isChainOfVoidAssignment(assignmentExpression)) {\n      // It is `exports.foo = void 0`\n      return;\n    }\n\n    const { name } = property.node;\n    if (name === '__esModule') {\n      return;\n    }\n\n    saveRef();\n    state.exports.push({ exported: property.node.name, local: right });\n\n    return;\n  }\n\n  if (\n    path.parentPath.isCallExpression() &&\n    path.parentPath.get('callee').matchesPattern('Object.defineProperty')\n  ) {\n    const [obj, prop, descriptor] = path.parentPath.get('arguments');\n    if (\n      obj?.isIdentifier(path.node) &&\n      prop?.isStringLiteral() &&\n      prop.node.value !== '__esModule' &&\n      descriptor?.isObjectExpression()\n    ) {\n      /**\n       *  Object.defineProperty(exports, \"token\", {\n       *    enumerable: true,\n       *    get: function get() {\n       *      return _unknownPackage.token;\n       *    }\n       *  });\n       */\n      const exported = prop.node.value;\n      const local = getGetterValueFromDescriptor(descriptor);\n      if (local) {\n        state.exports.push({ exported, local });\n      }\n    } else if (\n      obj?.isIdentifier(path.node) &&\n      prop?.isIdentifier() &&\n      descriptor?.isObjectExpression()\n    ) {\n      /**\n       *  Object.defineProperty(exports, key, {\n       *    enumerable: true,\n       *    get: function get() {\n       *      return _unknownPackage[key];\n       *    }\n       *  });\n       */\n      const local = getGetterValueFromDescriptor(descriptor);\n      if (local) {\n        state.exports.push({ exported: '*', local });\n      }\n    }\n  }\n}\n\nfunction collectFromRequireOrExports(\n  path: NodePath<Identifier>,\n  state: IState\n): void {\n  if (isRequire(path)) {\n    collectFromRequire(path, state);\n  } else if (isExports(path)) {\n    collectFromExports(path, state);\n  }\n}\n\nfunction unfoldNamespaceImport(\n  importItem: IImport & { imported: '*' }\n): IImport[] {\n  const result: IImport[] = [];\n  const { local } = importItem;\n  if (!local.isIdentifier()) {\n    // TODO: handle it\n    return [importItem];\n  }\n\n  const binding = local.scope.getBinding(local.node.name);\n  if (!binding?.referenced) {\n    // Imported namespace is not referenced and probably not used,\n    // but it can have side effects, so we should keep it as is\n    return [importItem];\n  }\n\n  for (const referencePath of binding?.referencePaths ?? []) {\n    if (\n      referencePath.find(\n        (ancestor) => ancestor.isTSType() || ancestor.isFlowType()\n      )\n    ) {\n      continue;\n    }\n\n    const { parentPath } = referencePath;\n    if (parentPath?.isMemberExpression() && referencePath.key === 'object') {\n      const property = parentPath.get('property');\n      const object = parentPath.get('object');\n      let imported: string | null;\n      if (parentPath.node.computed && property.isStringLiteral()) {\n        imported = property.node.value;\n      } else if (!parentPath.node.computed && property.isIdentifier()) {\n        imported = property.node.name;\n      } else {\n        imported = null;\n      }\n\n      if (object.isIdentifier() && imported) {\n        result.push({\n          ...importItem,\n          imported,\n          local: parentPath,\n        });\n      } else {\n        result.push(importItem);\n        break;\n      }\n\n      continue;\n    }\n\n    if (parentPath?.isVariableDeclarator() && referencePath.key === 'init') {\n      importFromVariableDeclarator(parentPath, true).map((prop) =>\n        result.push({ ...importItem, imported: prop.what, local: prop.as })\n      );\n\n      continue;\n    }\n\n    if (parentPath?.isExportSpecifier()) {\n      // The whole namespace is re-exported\n      result.push(importItem);\n      break;\n    }\n\n    // Otherwise, we can't predict usage and import it as is\n    // TODO: handle more cases\n    warn(\n      'evaluator:collectExportsAndImports:unfoldNamespaceImports',\n      'Unknown reference',\n      referencePath.node.type\n    );\n    result.push(importItem);\n    break;\n  }\n\n  return result;\n}\n\nfunction collectFromExportAllDeclaration(\n  path: NodePath<ExportAllDeclaration>,\n  state: IState\n): void {\n  if (isType(path)) return;\n  const source = path.get('source')?.node?.value;\n  if (!source) return;\n\n  // It is `export * from './css';`\n  state.reexports.push({\n    exported: '*',\n    imported: '*',\n    local: path,\n    source,\n  });\n}\n\nfunction collectFromExportSpecifier(\n  path: NodePath<\n    ExportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier\n  >,\n  source: string | undefined,\n  state: IState\n): void {\n  if (path.isExportSpecifier()) {\n    const exported = getValue(path.get('exported'));\n    if (source) {\n      // It is `export { foo } from './css';`\n      const imported = path.get('local').node.name;\n      state.reexports.push({\n        exported,\n        imported,\n        local: path,\n        source,\n      });\n    } else {\n      const local = path.get('local');\n      state.exports.push({ local, exported });\n    }\n\n    return;\n  }\n\n  if (path.isExportDefaultSpecifier() && source) {\n    // It is `export default from './css';`\n    state.reexports.push({\n      exported: 'default',\n      imported: 'default',\n      local: path,\n      source,\n    });\n  }\n\n  if (path.isExportNamespaceSpecifier() && source) {\n    const exported = path.get('exported').node.name;\n    // It is `export * as foo from './css';`\n    state.reexports.push({\n      exported,\n      imported: '*',\n      local: path,\n      source,\n    });\n  }\n\n  // TODO: handle other cases\n  warn(\n    'evaluator:collectExportsAndImports:collectFromExportSpecifier',\n    'Unprocessed ExportSpecifier',\n    path.node.type\n  );\n}\n\nfunction collectFromExportNamedDeclaration(\n  path: NodePath<ExportNamedDeclaration>,\n  state: IState\n): void {\n  if (isType(path)) return;\n\n  const source = path.get('source')?.node?.value;\n  const specifiers = path.get('specifiers');\n  if (specifiers) {\n    specifiers.forEach((specifier) =>\n      collectFromExportSpecifier(specifier, source, state)\n    );\n  }\n\n  const declaration = path.get('declaration');\n  if (declaration.isVariableDeclaration()) {\n    declaration.get('declarations').forEach((declarator) => {\n      exportFromVariableDeclarator(declarator).forEach((prop) => {\n        // What is defined\n        state.exports.push(prop);\n      });\n    });\n  }\n\n  if (declaration.isFunctionDeclaration()) {\n    const id = declaration.get('id');\n    if (id.isIdentifier()) {\n      state.exports.push({\n        exported: id.node.name,\n        local: id,\n      });\n    }\n  }\n}\n\nfunction collectFromExportDefaultDeclaration(\n  path: NodePath<ExportDefaultDeclaration>,\n  state: IState\n): void {\n  if (isType(path)) return;\n\n  const declaration = path.get('declaration');\n  state.exports.push({ exported: 'default', local: declaration });\n}\n\nconst cache = new WeakMap<NodePath, IState>();\n\nfunction collectFromAssignmentExpression(\n  path: NodePath<AssignmentExpression>,\n  state: IState\n): void {\n  const left = path.get('left');\n  const right = path.get('right');\n\n  let exported: IReexport['exported'] | undefined;\n\n  if (left.isMemberExpression() && isExports(left.get('object'))) {\n    const property = left.get('property');\n    if (property.isIdentifier()) {\n      exported = property.node.name;\n    }\n  } else if (isExports(left)) {\n    exported = '*'; // maybe\n  }\n\n  if (!exported) return;\n\n  if (!right.isCallExpression() || !isRequire(right.get('callee'))) return;\n\n  const sourcePath = right.get('arguments')?.[0];\n  const source = sourcePath.isStringLiteral()\n    ? sourcePath.node.value\n    : undefined;\n  if (!source) return;\n\n  // It is `exports.foo = require('./css');`\n\n  state.reexports.push({\n    exported,\n    imported: '*',\n    local: path,\n    source,\n  });\n\n  path.skip();\n}\n\nfunction collectFromCallExpression(\n  path: NodePath<CallExpression>,\n  state: IState\n) {\n  const maybeExportStart = path.get('callee');\n  if (\n    !maybeExportStart.isIdentifier() ||\n    !maybeExportStart.node.name.startsWith('__exportStar')\n  ) {\n    return;\n  }\n\n  const [requireCall, exports] = path.get('arguments');\n  if (!isExports(exports)) return;\n  if (!requireCall.isCallExpression()) return;\n  const callee = requireCall.get('callee');\n  const sourcePath = requireCall.get('arguments')?.[0];\n  if (!isRequire(callee) || !sourcePath.isStringLiteral()) return;\n\n  const source = sourcePath.node.value;\n  if (!source) return;\n\n  state.reexports.push({\n    exported: '*',\n    imported: '*',\n    local: path,\n    source,\n  });\n\n  path.skip();\n}\n\nexport default function collectExportsAndImports(\n  path: NodePath,\n  filename: string | null | undefined,\n  force = false\n): IState {\n  const state: IState = {\n    exportRefs: new Map(),\n    exports: [],\n    filename,\n    imports: [],\n    reexports: [],\n  };\n\n  if (!force && cache.has(path)) {\n    return cache.get(path) ?? state;\n  }\n\n  path.traverse(\n    {\n      AssignmentExpression: collectFromAssignmentExpression,\n      CallExpression: collectFromCallExpression,\n      ExportAllDeclaration: collectFromExportAllDeclaration,\n      ExportDefaultDeclaration: collectFromExportDefaultDeclaration,\n      ExportNamedDeclaration: collectFromExportNamedDeclaration,\n      ImportDeclaration: collectFromImportDeclaration,\n      Import: collectFromDynamicImport,\n      Identifier: collectFromRequireOrExports,\n    },\n    state\n  );\n\n  cache.set(path, state);\n\n  return state;\n}\n"],"mappings":";;;;;;;;AA2BA;;AAEA;;AACA;;AACA;;AACA;;;;AAhCA;;AACA;AAiEO,MAAMA,gBAAgB,GAC3BC,IAD8B,IAEAA,IAAI,CAACC,QAAL,KAAkB,IAF3C;;;;AAIA,MAAMC,cAAc,GACzBF,IAD4B,IAERA,IAAI,CAACC,QAAL,KAAkB,IAFjC;;;;AAIP,SAASE,QAAT,CAAkB;EAAEC;AAAF,CAAlB,EAA0E;EACxE,OAAOA,IAAI,CAACC,IAAL,KAAc,YAAd,GAA6BD,IAAI,CAACE,IAAlC,GAAyCF,IAAI,CAACG,KAArD;AACD,C,CAED;;;AACA,MAAMC,MAAM,GAAIC,CAAD,IAGZ,gBAAgBA,CAAC,CAACL,IAAlB,IAA0BK,CAAC,CAACL,IAAF,CAAOM,UAAP,KAAsB,MAAjD,IACC,gBAAgBD,CAAC,CAACL,IAAlB,IAA0BK,CAAC,CAACL,IAAF,CAAOO,UAAP,KAAsB,MAJnD,C,CAMA;;;AAEA,MAAMC,UAKL,GAAG;EACFC,eAAe,CAACC,IAAD,EAAkCC,MAAlC,EAAqD;IAClE,IAAIP,MAAM,CAACM,IAAD,CAAV,EAAkB,OAAO,EAAP;IAClB,MAAMb,QAAQ,GAAGE,QAAQ,CAACW,IAAI,CAACE,GAAL,CAAS,UAAT,CAAD,CAAzB;IACA,MAAMC,KAAK,GAAGH,IAAI,CAACE,GAAL,CAAS,OAAT,CAAd;IACA,OAAO,CAAC;MAAEf,QAAF;MAAYgB,KAAZ;MAAmBF;IAAnB,CAAD,CAAP;EACD,CANC;;EAQFG,sBAAsB,CACpBJ,IADoB,EAEpBC,MAFoB,EAGT;IACX,MAAME,KAAK,GAAGH,IAAI,CAACE,GAAL,CAAS,OAAT,CAAd;IACA,OAAO,CAAC;MAAEf,QAAQ,EAAE,SAAZ;MAAuBgB,KAAvB;MAA8BF;IAA9B,CAAD,CAAP;EACD,CAdC;;EAgBFI,wBAAwB,CACtBL,IADsB,EAEtBC,MAFsB,EAGX;IACX,MAAME,KAAK,GAAGH,IAAI,CAACE,GAAL,CAAS,OAAT,CAAd;IACA,OAAOI,qBAAqB,CAAC;MAAEnB,QAAQ,EAAE,GAAZ;MAAiBgB,KAAjB;MAAwBF;IAAxB,CAAD,CAA5B;EACD;;AAtBC,CALJ;;AA8BA,SAASM,4BAAT,CACEP,IADF,EAEEQ,KAFF,EAGQ;EACN;EACA,IAAId,MAAM,CAACM,IAAD,CAAV,EAAkB;EAElB,MAAMC,MAAM,GAAGZ,QAAQ,CAACW,IAAI,CAACE,GAAL,CAAS,QAAT,CAAD,CAAvB;EACA,MAAMO,UAAU,GAAGT,IAAI,CAACE,GAAL,CAAS,YAAT,CAAnB;;EAEA,IAAIO,UAAU,CAACC,MAAX,KAAsB,CAA1B,EAA6B;IAC3BF,KAAK,CAACG,OAAN,CAAcC,IAAd,CAAmB;MAAEzB,QAAQ,EAAE,IAAZ;MAAkBgB,KAAK,EAAEH,IAAzB;MAA+BC;IAA/B,CAAnB;EACD;;EAEDQ,UAAU,CAACI,OAAX,CAA8CC,SAA3B,IAAsD;IACvE,IAAIA,SAAS,CAACC,iBAAV,MAAiCrB,MAAM,CAACoB,SAAD,CAA3C,EAAwD;IAExD,MAAME,SAAS,GAAGlB,UAAU,CAC1BgB,SAAS,CAACxB,IAAV,CAAeC,IADW,CAA5B;IAIAiB,KAAK,CAACG,OAAN,CAAcC,IAAd,CAAmB,GAAGI,SAAS,CAACF,SAAD,EAAYb,MAAZ,CAA/B;EACD,CARD;AASD;;AAOD,SAASgB,iBAAT,CAA2BjB,IAA3B,EAA2CkB,IAA3C,EAA2E;EACzE,MAAMC,MAAkB,GAAG,EAA3B;EACA,IAAIC,OAAwB,GAAGpB,IAA/B;;EACA,OAAOoB,OAAO,IAAIF,IAAI,CAACE,OAAD,CAAtB,EAAiC;IAC/BD,MAAM,CAACP,IAAP,CAAYQ,OAAZ;IACAA,OAAO,GAAGA,OAAO,CAACC,UAAlB;EACD;;EAED,OAAOF,MAAP;AACD;;AAED,SAASG,gBAAT,CACEC,aADF,EAEiB;EACf,MAAMC,eAA8B,GAAG,EAAvC;EACAD,aAAa,CAACE,QAAd,CAAuB;IACrBC,UAAU,CAACC,UAAD,EAAa;MACrB,IAAIA,UAAU,CAACC,mBAAX,EAAJ,EAAsC;QACpC,MAAMC,MAAM,GAAGF,UAAU,CAACN,UAA1B;;QACA,IAAIQ,MAAM,CAACC,gBAAP,CAAwB;UAAErC,KAAK,EAAEkC,UAAU,CAACrC;QAApB,CAAxB,CAAJ,EAAyD;UACvD,MAAMyC,KAAK,GAAGd,iBAAiB,CAACY,MAAD,EAAUlC,CAAD,IAAOA,CAAC,KAAK4B,aAAtB,CAAjB,CACXS,MADW,CACJ,IAAAC,oBAAA,EAAY,gBAAZ,CADI,EAEXC,GAFW,CAENvC,CAAD,IAAO;YACV,MAAMwC,GAAG,GAAGxC,CAAC,CAACO,GAAF,CAAM,KAAN,CAAZ;;YACA,IAAI,CAACiC,GAAG,CAACC,YAAJ,EAAL,EAAyB;cACvB;cACA,OAAO,IAAP;YACD;;YAED,OAAOD,GAAP;UACD,CAVW,EAWXH,MAXW,CAWJK,kBAXI,CAAd;UAYAN,KAAK,CAACO,OAAN;;UAEA,IAAIP,KAAK,CAACrB,MAAN,GAAe,CAAnB,EAAsB;YACpBc,eAAe,CAACZ,IAAhB,CAAqB;cACnB2B,IAAI,EAAER,KAAK,CAAC,CAAD,CAAL,CAASzC,IAAT,CAAcE,IADD;cAEnBgD,EAAE,EAAEb;YAFe,CAArB;UAID;;UAED;QACD;;QAED,IAAIE,MAAM,CAACY,aAAP,CAAqB;UAAEC,QAAQ,EAAEf,UAAU,CAACrC;QAAvB,CAArB,CAAJ,EAAyD;UACvDkC,eAAe,CAACZ,IAAhB,CAAqB;YACnB2B,IAAI,EAAE,GADa;YAEnBC,EAAE,EAAEb;UAFe,CAArB;QAID;MACF;IACF;;EApCoB,CAAvB;EAuCA,OAAOH,eAAP;AACD;;AAED,SAASmB,4BAAT,CACE3C,IADF,EAEE4C,MAFF,EAGiB;EACf,MAAMC,EAAE,GAAG7C,IAAI,CAACE,GAAL,CAAS,IAAT,CAAX;;EACA,IAAI2C,EAAE,CAACT,YAAH,EAAJ,EAAuB;IACrB;IACA,OAAO,CACL;MACEI,EAAE,EAAEK,EADN;MAEEN,IAAI,EAAE;IAFR,CADK,CAAP;EAMD;;EAED,IAAI,CAACK,MAAL,EAAa;IACX;IACA;IACA,IAAAE,YAAA,EAAK,oCAAL,EAA2C,4BAA3C;IACA,OAAO,EAAP;EACD;;EAED,IAAID,EAAE,CAACE,eAAH,EAAJ,EAA0B;IACxB,OAAOzB,gBAAgB,CAACuB,EAAD,CAAvB;EACD,CArBc,CAuBf;;;EACA,IAAAC,YAAA,EACE,iEADF,EAEE,oBAFF,EAGED,EAAE,CAACvD,IAAH,CAAQC,IAHV;EAMA,OAAO,EAAP;AACD;;AAED,SAASyD,4BAAT,CACEhD,IADF,EAEa;EACX,MAAM6C,EAAE,GAAG7C,IAAI,CAACE,GAAL,CAAS,IAAT,CAAX;EACA,MAAM+C,IAAI,GAAGjD,IAAI,CAACE,GAAL,CAAS,MAAT,CAAb,CAFW,CAIX;;EACA,IAAI,CAAC+C,IAAD,IAAS,CAACA,IAAI,CAACC,YAAL,EAAd,EAAmC,OAAO,EAAP;;EAEnC,IAAIL,EAAE,CAACT,YAAH,EAAJ,EAAuB;IACrB;IACA,OAAO,CACL;MACEjC,KAAK,EAAE8C,IADT;MAEEE,QAAQ,EAAEN,EAAE,CAACvD,IAAH,CAAQE;IAFpB,CADK,CAAP;EAMD;;EAED,IAAIqD,EAAE,CAACE,eAAH,EAAJ,EAA0B;IACxB;IACA,OAAOzB,gBAAgB,CAACuB,EAAD,CAAhB,CAAqBX,GAArB,CAA0BkB,UAAD,KAAiB;MAC/CjD,KAAK,EAAE8C,IADwC;MAE/CE,QAAQ,EAAEC,UAAU,CAACZ,EAAX,CAAclD,IAAd,CAAmBE;IAFkB,CAAjB,CAAzB,CAAP;EAID,CAvBU,CAyBX;;;EACA,IAAAsD,YAAA,EACE,iEADF,EAEE,oBAFF,EAGED,EAAE,CAACvD,IAAH,CAAQC,IAHV;EAMA,OAAO,EAAP;AACD;;AAED,SAAS8D,wBAAT,CAAkCrD,IAAlC,EAA0DQ,KAA1D,EAA+E;EAC7E,MAAM;IAAEa,UAAU,EAAEiC;EAAd,IAAiCtD,IAAvC;;EACA,IAAI,CAACsD,cAAc,CAACC,gBAAf,EAAL,EAAwC;IACtC;IACA;EACD;;EAED,MAAM,CAACC,UAAD,IAAeF,cAAc,CAACpD,GAAf,CAAmB,WAAnB,CAArB;;EACA,IAAI,CAACsD,UAAD,IAAe,CAACA,UAAU,CAACC,eAAX,EAApB,EAAkD;IAChD;IACA;EACD;;EAED,MAAMxD,MAAM,GAAGuD,UAAU,CAAClE,IAAX,CAAgBG,KAA/B;EAEA,IAAI;IAAE4B,UAAU,EAAEqC,SAAd;IAAyBvB;EAAzB,IAAiCmB,cAArC;EACA,IAAIK,SAAS,GAAG,KAAhB;;EAEA,IAAID,SAAS,CAACE,iBAAV,EAAJ,EAAmC;IACjC;IACAD,SAAS,GAAG,IAAZ;IACAxB,GAAG,GAAGuB,SAAS,CAACvB,GAAhB;IACAuB,SAAS,GAAGA,SAAS,CAACrC,UAAtB;EACD,CAvB4E,CAyB7E;;;EACA,IAAIc,GAAG,KAAK,MAAR,IAAkBuB,SAAS,CAACG,oBAAV,EAAtB,EAAwD;IACtDlB,4BAA4B,CAACe,SAAD,EAAYC,SAAZ,CAA5B,CAAmDzB,GAAnD,CAAwD4B,IAAD,IACrDtD,KAAK,CAACG,OAAN,CAAcC,IAAd,CAAmB;MAAEzB,QAAQ,EAAE2E,IAAI,CAACvB,IAAjB;MAAuBpC,KAAK,EAAE2D,IAAI,CAACtB,EAAnC;MAAuCvC;IAAvC,CAAnB,CADF;EAGD;AACF;;AAED,SAAS8D,8BAAT,CACE/D,IADF,EAE+B;EAC7B,MAAMgE,MAAM,GAAGhE,IAAI,CAACE,GAAL,CAAS,QAAT,CAAf;;EACA,IAAI,CAAC8D,MAAM,CAAC5B,YAAP,EAAL,EAA4B;IAC1B,OAAO6B,SAAP;EACD;;EAED,MAAM;IAAEzE;EAAF,IAAWwE,MAAM,CAAC1E,IAAxB;;EACA,IACEE,IAAI,CAAC0E,UAAL,CAAgB,wBAAhB,KACA1E,IAAI,CAAC0E,UAAL,CAAgB,iBAAhB,CAFF,EAGE;IACA,OAAO,SAAP;EACD;;EAED,IACE1E,IAAI,CAAC0E,UAAL,CAAgB,yBAAhB,KACA1E,IAAI,CAAC0E,UAAL,CAAgB,cAAhB,CAFF,EAGE;IACA,OAAO,GAAP;EACD;;EAED,IAAI1E,IAAI,CAAC0E,UAAL,CAAgB,QAAhB,CAAJ,EAA+B;IAC7B,OAAO,GAAP;EACD;;EAED,OAAOD,SAAP;AACD;;AAED,SAASE,kBAAT,CAA4BnE,IAA5B,EAAwDQ,KAAxD,EAA6E;EAC3E,IAAI,CAAC,IAAA4D,kBAAA,EAAUpE,IAAV,CAAL,EAAsB;EAEtB,MAAM;IAAEqB,UAAU,EAAEiC;EAAd,IAAiCtD,IAAvC;;EACA,IAAI,CAACsD,cAAc,CAACC,gBAAf,EAAL,EAAwC;IACtC;IACA;EACD;;EAED,MAAM,CAACC,UAAD,IAAeF,cAAc,CAACpD,GAAf,CAAmB,WAAnB,CAArB;;EACA,IAAI,CAACsD,UAAD,IAAe,CAACA,UAAU,CAACC,eAAX,EAApB,EAAkD;IAChD;IACA;EACD;;EAED,MAAMxD,MAAM,GAAGuD,UAAU,CAAClE,IAAX,CAAgBG,KAA/B;EAEA,MAAM;IAAE4B,UAAU,EAAEqC,SAAd;IAAyBvB;EAAzB,IAAiCmB,cAAvC;;EAEA,IAAII,SAAS,CAACH,gBAAV,MAAgCpB,GAAG,KAAK,CAA5C,EAA+C;IAC7C;IACA;IACA,MAAMhD,QAAQ,GAAG4E,8BAA8B,CAACL,SAAD,CAA/C;;IACA,IAAI,CAACvE,QAAL,EAAe;MACb;MACA;MACA,IAAA2D,YAAA,EACE,oCADF,EAEE,4BAFF,EAGEY,SAAS,CAACpE,IAAV,CAAe0E,MAHjB;MAKA;IACD;;IAED,MAAM;MAAE3C,UAAU,EAAEgD;IAAd,IAAqCX,SAA3C;;IACA,IAAI,CAACW,kBAAkB,CAACR,oBAAnB,EAAL,EAAgD;MAC9C;MACA,IAAAf,YAAA,EACE,oCADF,EAEE,2BAFF,EAGEuB,kBAAkB,CAAC/E,IAAnB,CAAwBC,IAH1B;MAKA;IACD;;IAED,MAAMsD,EAAE,GAAGwB,kBAAkB,CAACnE,GAAnB,CAAuB,IAAvB,CAAX;;IACA,IAAI,CAAC2C,EAAE,CAACT,YAAH,EAAL,EAAwB;MACtB,IAAAU,YAAA,EACE,oCADF,EAEE,yBAFF,EAGEuB,kBAAkB,CAAC/E,IAAnB,CAAwBC,IAH1B;MAKA;IACD;;IAED,IAAIJ,QAAQ,KAAK,GAAjB,EAAsB;MACpB,MAAMmF,QAAQ,GAAGhE,qBAAqB,CAAC;QACrCnB,QADqC;QAErCgB,KAAK,EAAE0C,EAF8B;QAGrC5C;MAHqC,CAAD,CAAtC;MAKAO,KAAK,CAACG,OAAN,CAAcC,IAAd,CAAmB,GAAG0D,QAAtB;IACD,CAPD,MAOO;MACL9D,KAAK,CAACG,OAAN,CAAcC,IAAd,CAAmB;QACjBzB,QADiB;QAEjBgB,KAAK,EAAE0C,EAFU;QAGjB5C;MAHiB,CAAnB;IAKD;EACF;;EAED,IAAIyD,SAAS,CAACa,kBAAV,EAAJ,EAAoC;IAClC;IACA,MAAMC,QAAQ,GAAGd,SAAS,CAACxD,GAAV,CAAc,UAAd,CAAjB;;IACA,IAAI,CAACsE,QAAQ,CAACpC,YAAT,EAAD,IAA4B,CAACoC,QAAQ,CAACf,eAAT,EAAjC,EAA6D;MAC3D,IAAAX,YAAA,EACE,oCADF,EAEE,gDAFF,EAGE0B,QAAQ,CAAClF,IAAT,CAAcC,IAHhB;MAMA;IACD;;IAED,MAAM;MAAE8B,UAAU,EAAEgD;IAAd,IAAqCX,SAA3C;;IAEA,IAAIW,kBAAkB,CAACR,oBAAnB,EAAJ,EAA+C;MAC7C;MACA,MAAMhB,EAAE,GAAGwB,kBAAkB,CAACnE,GAAnB,CAAuB,IAAvB,CAAX;;MACA,IAAI2C,EAAE,CAACT,YAAH,EAAJ,EAAuB;QACrB5B,KAAK,CAACG,OAAN,CAAcC,IAAd,CAAmB;UACjBzB,QAAQ,EAAEE,QAAQ,CAACmF,QAAD,CADD;UAEjBrE,KAAK,EAAE0C,EAFU;UAGjB5C;QAHiB,CAAnB;MAKD,CAND,MAMO;QACL,IAAA6C,YAAA,EACE,oCADF,EAEE,yBAFF,EAGEuB,kBAAkB,CAAC/E,IAAnB,CAAwBC,IAH1B;MAKD;IACF,CAhBD,MAgBO;MACL;MACA;MACAiB,KAAK,CAACG,OAAN,CAAcC,IAAd,CAAmB;QACjBzB,QAAQ,EAAEE,QAAQ,CAACmF,QAAD,CADD;QAEjBrE,KAAK,EAAEuD,SAFU;QAGjBzD;MAHiB,CAAnB;IAKD;;IAED;EACD,CAjH0E,CAmH3E;;;EACA,IAAIkC,GAAG,KAAK,MAAR,IAAkBuB,SAAS,CAACG,oBAAV,EAAtB,EAAwD;IACtDlB,4BAA4B,CAACe,SAAD,EAAY,IAAZ,CAA5B,CAA8C7C,OAA9C,CAAuDiD,IAAD,IAAU;MAC9D,IAAIA,IAAI,CAACvB,IAAL,KAAc,GAAlB,EAAuB;QACrB,MAAM+B,QAAQ,GAAGhE,qBAAqB,CAAC;UACrCnB,QAAQ,EAAE,GAD2B;UAErCgB,KAAK,EAAE2D,IAAI,CAACtB,EAFyB;UAGrCvC;QAHqC,CAAD,CAAtC;QAMAO,KAAK,CAACG,OAAN,CAAcC,IAAd,CAAmB,GAAG0D,QAAtB;MACD,CARD,MAQO;QACL9D,KAAK,CAACG,OAAN,CAAcC,IAAd,CAAmB;UACjBzB,QAAQ,EAAE2E,IAAI,CAACvB,IADE;UAEjBpC,KAAK,EAAE2D,IAAI,CAACtB,EAFK;UAGjBvC;QAHiB,CAAnB;MAKD;IACF,CAhBD;EAiBD;;EAED,IAAIyD,SAAS,CAACe,qBAAV,EAAJ,EAAuC;IACrC;IACAjE,KAAK,CAACG,OAAN,CAAcC,IAAd,CAAmB;MACjBzB,QAAQ,EAAE,IADO;MAEjBgB,KAAK,EAAEuD,SAFU;MAGjBzD;IAHiB,CAAnB;EAKD;AACF;;AAED,SAASyE,uBAAT,CACE1E,IADF,EAEW;EACT,MAAM2E,KAAK,GAAG3E,IAAI,CAACE,GAAL,CAAS,OAAT,CAAd;;EACA,IAAIyE,KAAK,CAACC,iBAAN,CAAwB;IAAEC,QAAQ,EAAE;EAAZ,CAAxB,CAAJ,EAAmD;IACjD,OAAO,IAAP;EACD;;EAED,IAAIF,KAAK,CAACG,sBAAN,EAAJ,EAAoC;IAClC,OAAOJ,uBAAuB,CAACC,KAAD,CAA9B;EACD;;EAED,OAAO,KAAP;AACD;;AAED,SAASI,4BAAT,CACEC,UADF,EAEoC;EAClC,MAAMC,MAAM,GAAGD,UAAU,CACtB9E,GADY,CACR,YADQ,EAEZ8B,MAFY,CAEL,IAAAC,oBAAA,EAAY,gBAAZ,CAFK,EAGZiD,IAHY,CAGNvF,CAAD,IAAOA,CAAC,CAACO,GAAF,CAAM,KAAN,EAAakC,YAAb,CAA0B;IAAE5C,IAAI,EAAE;EAAR,CAA1B,CAHA,CAAf;EAIA,MAAMC,KAAK,GAAGwF,MAAH,aAAGA,MAAH,uBAAGA,MAAM,CAAE/E,GAAR,CAAY,OAAZ,CAAd;;EACA,IAAIT,KAAJ,aAAIA,KAAJ,eAAIA,KAAK,CAAE0F,oBAAP,EAAJ,EAAmC;IACjC,MAAMC,eAAe,GAAG3F,KAAK,CAACS,GAAN,CAAU,MAAV,EAAkBA,GAAlB,CAAsB,MAAtB,EAA8B,CAA9B,CAAxB;;IACA,IAAIkF,eAAJ,aAAIA,eAAJ,eAAIA,eAAe,CAAEC,iBAAjB,EAAJ,EAA0C;MACxC,MAAMlF,KAAK,GAAGiF,eAAe,CAAClF,GAAhB,CAAoB,UAApB,CAAd;;MACA,IAAIC,KAAK,CAAC+C,YAAN,EAAJ,EAA0B;QACxB,OAAO/C,KAAP;MACD;IACF;EACF;;EAED,OAAO8D,SAAP;AACD;;AAED,SAASqB,kBAAT,CAA4BtF,IAA5B,EAAwDQ,KAAxD,EAA6E;EAC3E,IAAI,CAAC,IAAA+E,kBAAA,EAAUvF,IAAV,CAAL,EAAsB;;EAEtB,IAAIA,IAAI,CAACqB,UAAL,CAAgBkD,kBAAhB,CAAmC;IAAEiB,MAAM,EAAExF,IAAI,CAACV;EAAf,CAAnC,CAAJ,EAA+D;IAC7D;IACA,MAAMmG,gBAAgB,GAAGzF,IAAI,CAACqB,UAA9B;IACA,MAAMmD,QAAQ,GAAGiB,gBAAgB,CAACvF,GAAjB,CAAqB,UAArB,CAAjB;;IACA,IAAI,CAACsE,QAAQ,CAACpC,YAAT,EAAL,EAA8B;MAC5B;IACD;;IAED,MAAMsD,UAAU,GAAGlB,QAAQ,CAAClF,IAAT,CAAcE,IAAjC;;IAEA,MAAMmG,OAAO,GAAG,MAAM;MACpB;MACA,IAAI,CAACnF,KAAK,CAACoF,UAAN,CAAiBC,GAAjB,CAAqBH,UAArB,CAAL,EAAuC;QACrClF,KAAK,CAACoF,UAAN,CAAiBE,GAAjB,CAAqBJ,UAArB,EAAiC,EAAjC;MACD;;MAEDlF,KAAK,CAACoF,UAAN,CAAiB1F,GAAjB,CAAqBwF,UAArB,EAAkC9E,IAAlC,CAAuC6E,gBAAvC;IACD,CAPD;;IASA,MAAMM,oBAAoB,GAAGN,gBAAgB,CAACpE,UAA9C;;IAEA,IACE,CAAC0E,oBAAoB,CAACjB,sBAArB,CAA4C;MAC3CkB,IAAI,EAAEP,gBAAgB,CAACnG;IADoB,CAA5C,CADH,EAIE;MACA;MACAqG,OAAO;MACP;IACD;;IAED,MAAMhB,KAAK,GAAGoB,oBAAoB,CAAC7F,GAArB,CAAyB,OAAzB,CAAd;;IAEA,IAAIwE,uBAAuB,CAACqB,oBAAD,CAA3B,EAAmD;MACjD;MACA;IACD;;IAED,MAAM;MAAEvG;IAAF,IAAWgF,QAAQ,CAAClF,IAA1B;;IACA,IAAIE,IAAI,KAAK,YAAb,EAA2B;MACzB;IACD;;IAEDmG,OAAO;IACPnF,KAAK,CAACyF,OAAN,CAAcrF,IAAd,CAAmB;MAAEuC,QAAQ,EAAEqB,QAAQ,CAAClF,IAAT,CAAcE,IAA1B;MAAgCW,KAAK,EAAEwE;IAAvC,CAAnB;IAEA;EACD;;EAED,IACE3E,IAAI,CAACqB,UAAL,CAAgBkC,gBAAhB,MACAvD,IAAI,CAACqB,UAAL,CAAgBnB,GAAhB,CAAoB,QAApB,EAA8BgG,cAA9B,CAA6C,uBAA7C,CAFF,EAGE;IACA,MAAM,CAACC,GAAD,EAAMrC,IAAN,EAAYkB,UAAZ,IAA0BhF,IAAI,CAACqB,UAAL,CAAgBnB,GAAhB,CAAoB,WAApB,CAAhC;;IACA,IACEiG,GAAG,SAAH,IAAAA,GAAG,WAAH,IAAAA,GAAG,CAAE/D,YAAL,CAAkBpC,IAAI,CAACV,IAAvB,KACAwE,IADA,aACAA,IADA,eACAA,IAAI,CAAEL,eAAN,EADA,IAEAK,IAAI,CAACxE,IAAL,CAAUG,KAAV,KAAoB,YAFpB,IAGAuF,UAHA,aAGAA,UAHA,eAGAA,UAAU,CAAEoB,kBAAZ,EAJF,EAKE;MACA;AACN;AACA;AACA;AACA;AACA;AACA;AACA;MACM,MAAMjD,QAAQ,GAAGW,IAAI,CAACxE,IAAL,CAAUG,KAA3B;MACA,MAAMU,KAAK,GAAG4E,4BAA4B,CAACC,UAAD,CAA1C;;MACA,IAAI7E,KAAJ,EAAW;QACTK,KAAK,CAACyF,OAAN,CAAcrF,IAAd,CAAmB;UAAEuC,QAAF;UAAYhD;QAAZ,CAAnB;MACD;IACF,CAnBD,MAmBO,IACLgG,GAAG,SAAH,IAAAA,GAAG,WAAH,IAAAA,GAAG,CAAE/D,YAAL,CAAkBpC,IAAI,CAACV,IAAvB,KACAwE,IADA,aACAA,IADA,eACAA,IAAI,CAAE1B,YAAN,EADA,IAEA4C,UAFA,aAEAA,UAFA,eAEAA,UAAU,CAAEoB,kBAAZ,EAHK,EAIL;MACA;AACN;AACA;AACA;AACA;AACA;AACA;AACA;MACM,MAAMjG,KAAK,GAAG4E,4BAA4B,CAACC,UAAD,CAA1C;;MACA,IAAI7E,KAAJ,EAAW;QACTK,KAAK,CAACyF,OAAN,CAAcrF,IAAd,CAAmB;UAAEuC,QAAQ,EAAE,GAAZ;UAAiBhD;QAAjB,CAAnB;MACD;IACF;EACF;AACF;;AAED,SAASkG,2BAAT,CACErG,IADF,EAEEQ,KAFF,EAGQ;EACN,IAAI,IAAA4D,kBAAA,EAAUpE,IAAV,CAAJ,EAAqB;IACnBmE,kBAAkB,CAACnE,IAAD,EAAOQ,KAAP,CAAlB;EACD,CAFD,MAEO,IAAI,IAAA+E,kBAAA,EAAUvF,IAAV,CAAJ,EAAqB;IAC1BsF,kBAAkB,CAACtF,IAAD,EAAOQ,KAAP,CAAlB;EACD;AACF;;AAED,SAASF,qBAAT,CACEgG,UADF,EAEa;EACX,MAAMnF,MAAiB,GAAG,EAA1B;EACA,MAAM;IAAEhB;EAAF,IAAYmG,UAAlB;;EACA,IAAI,CAACnG,KAAK,CAACiC,YAAN,EAAL,EAA2B;IACzB;IACA,OAAO,CAACkE,UAAD,CAAP;EACD;;EAED,MAAMC,OAAO,GAAGpG,KAAK,CAACqG,KAAN,CAAYC,UAAZ,CAAuBtG,KAAK,CAACb,IAAN,CAAWE,IAAlC,CAAhB;;EACA,IAAI,EAAC+G,OAAD,aAACA,OAAD,eAACA,OAAO,CAAEG,UAAV,CAAJ,EAA0B;IACxB;IACA;IACA,OAAO,CAACJ,UAAD,CAAP;EACD;;EAED,KAAK,MAAMK,aAAX,6BAA4BJ,OAA5B,aAA4BA,OAA5B,uBAA4BA,OAAO,CAAEK,cAArC,yEAAuD,EAAvD,EAA2D;IAAA;;IACzD,IACED,aAAa,CAACzB,IAAd,CACG2B,QAAD,IAAcA,QAAQ,CAACC,QAAT,MAAuBD,QAAQ,CAACE,UAAT,EADvC,CADF,EAIE;MACA;IACD;;IAED,MAAM;MAAE1F;IAAF,IAAiBsF,aAAvB;;IACA,IAAItF,UAAU,SAAV,IAAAA,UAAU,WAAV,IAAAA,UAAU,CAAEkD,kBAAZ,MAAoCoC,aAAa,CAACxE,GAAd,KAAsB,QAA9D,EAAwE;MACtE,MAAMqC,QAAQ,GAAGnD,UAAU,CAACnB,GAAX,CAAe,UAAf,CAAjB;MACA,MAAMsF,MAAM,GAAGnE,UAAU,CAACnB,GAAX,CAAe,QAAf,CAAf;MACA,IAAIf,QAAJ;;MACA,IAAIkC,UAAU,CAAC/B,IAAX,CAAgB0H,QAAhB,IAA4BxC,QAAQ,CAACf,eAAT,EAAhC,EAA4D;QAC1DtE,QAAQ,GAAGqF,QAAQ,CAAClF,IAAT,CAAcG,KAAzB;MACD,CAFD,MAEO,IAAI,CAAC4B,UAAU,CAAC/B,IAAX,CAAgB0H,QAAjB,IAA6BxC,QAAQ,CAACpC,YAAT,EAAjC,EAA0D;QAC/DjD,QAAQ,GAAGqF,QAAQ,CAAClF,IAAT,CAAcE,IAAzB;MACD,CAFM,MAEA;QACLL,QAAQ,GAAG,IAAX;MACD;;MAED,IAAIqG,MAAM,CAACpD,YAAP,MAAyBjD,QAA7B,EAAuC;QACrCgC,MAAM,CAACP,IAAP,CAAY,EACV,GAAG0F,UADO;UAEVnH,QAFU;UAGVgB,KAAK,EAAEkB;QAHG,CAAZ;MAKD,CAND,MAMO;QACLF,MAAM,CAACP,IAAP,CAAY0F,UAAZ;QACA;MACD;;MAED;IACD;;IAED,IAAIjF,UAAU,SAAV,IAAAA,UAAU,WAAV,IAAAA,UAAU,CAAEwC,oBAAZ,MAAsC8C,aAAa,CAACxE,GAAd,KAAsB,MAAhE,EAAwE;MACtEQ,4BAA4B,CAACtB,UAAD,EAAa,IAAb,CAA5B,CAA+Ca,GAA/C,CAAoD4B,IAAD,IACjD3C,MAAM,CAACP,IAAP,CAAY,EAAE,GAAG0F,UAAL;QAAiBnH,QAAQ,EAAE2E,IAAI,CAACvB,IAAhC;QAAsCpC,KAAK,EAAE2D,IAAI,CAACtB;MAAlD,CAAZ,CADF;MAIA;IACD;;IAED,IAAInB,UAAJ,aAAIA,UAAJ,eAAIA,UAAU,CAAE4F,iBAAZ,EAAJ,EAAqC;MACnC;MACA9F,MAAM,CAACP,IAAP,CAAY0F,UAAZ;MACA;IACD,CAhDwD,CAkDzD;IACA;;;IACA,IAAAxD,YAAA,EACE,2DADF,EAEE,mBAFF,EAGE6D,aAAa,CAACrH,IAAd,CAAmBC,IAHrB;IAKA4B,MAAM,CAACP,IAAP,CAAY0F,UAAZ;IACA;EACD;;EAED,OAAOnF,MAAP;AACD;;AAED,SAAS+F,+BAAT,CACElH,IADF,EAEEQ,KAFF,EAGQ;EAAA;;EACN,IAAId,MAAM,CAACM,IAAD,CAAV,EAAkB;EAClB,MAAMC,MAAM,gBAAGD,IAAI,CAACE,GAAL,CAAS,QAAT,CAAH,gEAAG,UAAoBZ,IAAvB,mDAAG,eAA0BG,KAAzC;EACA,IAAI,CAACQ,MAAL,EAAa,OAHP,CAKN;;EACAO,KAAK,CAAC2G,SAAN,CAAgBvG,IAAhB,CAAqB;IACnBuC,QAAQ,EAAE,GADS;IAEnBhE,QAAQ,EAAE,GAFS;IAGnBgB,KAAK,EAAEH,IAHY;IAInBC;EAJmB,CAArB;AAMD;;AAED,SAASmH,0BAAT,CACEpH,IADF,EAIEC,MAJF,EAKEO,KALF,EAMQ;EACN,IAAIR,IAAI,CAACiH,iBAAL,EAAJ,EAA8B;IAC5B,MAAM9D,QAAQ,GAAG9D,QAAQ,CAACW,IAAI,CAACE,GAAL,CAAS,UAAT,CAAD,CAAzB;;IACA,IAAID,MAAJ,EAAY;MACV;MACA,MAAMd,QAAQ,GAAGa,IAAI,CAACE,GAAL,CAAS,OAAT,EAAkBZ,IAAlB,CAAuBE,IAAxC;MACAgB,KAAK,CAAC2G,SAAN,CAAgBvG,IAAhB,CAAqB;QACnBuC,QADmB;QAEnBhE,QAFmB;QAGnBgB,KAAK,EAAEH,IAHY;QAInBC;MAJmB,CAArB;IAMD,CATD,MASO;MACL,MAAME,KAAK,GAAGH,IAAI,CAACE,GAAL,CAAS,OAAT,CAAd;MACAM,KAAK,CAACyF,OAAN,CAAcrF,IAAd,CAAmB;QAAET,KAAF;QAASgD;MAAT,CAAnB;IACD;;IAED;EACD;;EAED,IAAInD,IAAI,CAACqH,wBAAL,MAAmCpH,MAAvC,EAA+C;IAC7C;IACAO,KAAK,CAAC2G,SAAN,CAAgBvG,IAAhB,CAAqB;MACnBuC,QAAQ,EAAE,SADS;MAEnBhE,QAAQ,EAAE,SAFS;MAGnBgB,KAAK,EAAEH,IAHY;MAInBC;IAJmB,CAArB;EAMD;;EAED,IAAID,IAAI,CAACsH,0BAAL,MAAqCrH,MAAzC,EAAiD;IAC/C,MAAMkD,QAAQ,GAAGnD,IAAI,CAACE,GAAL,CAAS,UAAT,EAAqBZ,IAArB,CAA0BE,IAA3C,CAD+C,CAE/C;;IACAgB,KAAK,CAAC2G,SAAN,CAAgBvG,IAAhB,CAAqB;MACnBuC,QADmB;MAEnBhE,QAAQ,EAAE,GAFS;MAGnBgB,KAAK,EAAEH,IAHY;MAInBC;IAJmB,CAArB;EAMD,CAvCK,CAyCN;;;EACA,IAAA6C,YAAA,EACE,+DADF,EAEE,6BAFF,EAGE9C,IAAI,CAACV,IAAL,CAAUC,IAHZ;AAKD;;AAED,SAASgI,iCAAT,CACEvH,IADF,EAEEQ,KAFF,EAGQ;EAAA;;EACN,IAAId,MAAM,CAACM,IAAD,CAAV,EAAkB;EAElB,MAAMC,MAAM,iBAAGD,IAAI,CAACE,GAAL,CAAS,QAAT,CAAH,kEAAG,WAAoBZ,IAAvB,oDAAG,gBAA0BG,KAAzC;EACA,MAAMgB,UAAU,GAAGT,IAAI,CAACE,GAAL,CAAS,YAAT,CAAnB;;EACA,IAAIO,UAAJ,EAAgB;IACdA,UAAU,CAACI,OAAX,CAAoBC,SAAD,IACjBsG,0BAA0B,CAACtG,SAAD,EAAYb,MAAZ,EAAoBO,KAApB,CAD5B;EAGD;;EAED,MAAMgH,WAAW,GAAGxH,IAAI,CAACE,GAAL,CAAS,aAAT,CAApB;;EACA,IAAIsH,WAAW,CAACC,qBAAZ,EAAJ,EAAyC;IACvCD,WAAW,CAACtH,GAAZ,CAAgB,cAAhB,EAAgCW,OAAhC,CAAyC6G,UAAD,IAAgB;MACtD1E,4BAA4B,CAAC0E,UAAD,CAA5B,CAAyC7G,OAAzC,CAAkDiD,IAAD,IAAU;QACzD;QACAtD,KAAK,CAACyF,OAAN,CAAcrF,IAAd,CAAmBkD,IAAnB;MACD,CAHD;IAID,CALD;EAMD;;EAED,IAAI0D,WAAW,CAACG,qBAAZ,EAAJ,EAAyC;IACvC,MAAM9E,EAAE,GAAG2E,WAAW,CAACtH,GAAZ,CAAgB,IAAhB,CAAX;;IACA,IAAI2C,EAAE,CAACT,YAAH,EAAJ,EAAuB;MACrB5B,KAAK,CAACyF,OAAN,CAAcrF,IAAd,CAAmB;QACjBuC,QAAQ,EAAEN,EAAE,CAACvD,IAAH,CAAQE,IADD;QAEjBW,KAAK,EAAE0C;MAFU,CAAnB;IAID;EACF;AACF;;AAED,SAAS+E,mCAAT,CACE5H,IADF,EAEEQ,KAFF,EAGQ;EACN,IAAId,MAAM,CAACM,IAAD,CAAV,EAAkB;EAElB,MAAMwH,WAAW,GAAGxH,IAAI,CAACE,GAAL,CAAS,aAAT,CAApB;EACAM,KAAK,CAACyF,OAAN,CAAcrF,IAAd,CAAmB;IAAEuC,QAAQ,EAAE,SAAZ;IAAuBhD,KAAK,EAAEqH;EAA9B,CAAnB;AACD;;AAED,MAAMK,KAAK,GAAG,IAAIC,OAAJ,EAAd;;AAEA,SAASC,+BAAT,CACE/H,IADF,EAEEQ,KAFF,EAGQ;EAAA;;EACN,MAAMwF,IAAI,GAAGhG,IAAI,CAACE,GAAL,CAAS,MAAT,CAAb;EACA,MAAMyE,KAAK,GAAG3E,IAAI,CAACE,GAAL,CAAS,OAAT,CAAd;EAEA,IAAIiD,QAAJ;;EAEA,IAAI6C,IAAI,CAACzB,kBAAL,MAA6B,IAAAgB,kBAAA,EAAUS,IAAI,CAAC9F,GAAL,CAAS,QAAT,CAAV,CAAjC,EAAgE;IAC9D,MAAMsE,QAAQ,GAAGwB,IAAI,CAAC9F,GAAL,CAAS,UAAT,CAAjB;;IACA,IAAIsE,QAAQ,CAACpC,YAAT,EAAJ,EAA6B;MAC3Be,QAAQ,GAAGqB,QAAQ,CAAClF,IAAT,CAAcE,IAAzB;IACD;EACF,CALD,MAKO,IAAI,IAAA+F,kBAAA,EAAUS,IAAV,CAAJ,EAAqB;IAC1B7C,QAAQ,GAAG,GAAX,CAD0B,CACV;EACjB;;EAED,IAAI,CAACA,QAAL,EAAe;EAEf,IAAI,CAACwB,KAAK,CAACpB,gBAAN,EAAD,IAA6B,CAAC,IAAAa,kBAAA,EAAUO,KAAK,CAACzE,GAAN,CAAU,QAAV,CAAV,CAAlC,EAAkE;EAElE,MAAMsD,UAAU,iBAAGmB,KAAK,CAACzE,GAAN,CAAU,WAAV,CAAH,+CAAG,WAAyB,CAAzB,CAAnB;EACA,MAAMD,MAAM,GAAGuD,UAAU,CAACC,eAAX,KACXD,UAAU,CAAClE,IAAX,CAAgBG,KADL,GAEXwE,SAFJ;EAGA,IAAI,CAAChE,MAAL,EAAa,OAvBP,CAyBN;;EAEAO,KAAK,CAAC2G,SAAN,CAAgBvG,IAAhB,CAAqB;IACnBuC,QADmB;IAEnBhE,QAAQ,EAAE,GAFS;IAGnBgB,KAAK,EAAEH,IAHY;IAInBC;EAJmB,CAArB;EAOAD,IAAI,CAACgI,IAAL;AACD;;AAED,SAASC,yBAAT,CACEjI,IADF,EAEEQ,KAFF,EAGE;EAAA;;EACA,MAAM0H,gBAAgB,GAAGlI,IAAI,CAACE,GAAL,CAAS,QAAT,CAAzB;;EACA,IACE,CAACgI,gBAAgB,CAAC9F,YAAjB,EAAD,IACA,CAAC8F,gBAAgB,CAAC5I,IAAjB,CAAsBE,IAAtB,CAA2B0E,UAA3B,CAAsC,cAAtC,CAFH,EAGE;IACA;EACD;;EAED,MAAM,CAACiE,WAAD,EAAclC,OAAd,IAAyBjG,IAAI,CAACE,GAAL,CAAS,WAAT,CAA/B;EACA,IAAI,CAAC,IAAAqF,kBAAA,EAAUU,OAAV,CAAL,EAAyB;EACzB,IAAI,CAACkC,WAAW,CAAC5E,gBAAZ,EAAL,EAAqC;EACrC,MAAMS,MAAM,GAAGmE,WAAW,CAACjI,GAAZ,CAAgB,QAAhB,CAAf;EACA,MAAMsD,UAAU,uBAAG2E,WAAW,CAACjI,GAAZ,CAAgB,WAAhB,CAAH,qDAAG,iBAA+B,CAA/B,CAAnB;EACA,IAAI,CAAC,IAAAkE,kBAAA,EAAUJ,MAAV,CAAD,IAAsB,CAACR,UAAU,CAACC,eAAX,EAA3B,EAAyD;EAEzD,MAAMxD,MAAM,GAAGuD,UAAU,CAAClE,IAAX,CAAgBG,KAA/B;EACA,IAAI,CAACQ,MAAL,EAAa;EAEbO,KAAK,CAAC2G,SAAN,CAAgBvG,IAAhB,CAAqB;IACnBuC,QAAQ,EAAE,GADS;IAEnBhE,QAAQ,EAAE,GAFS;IAGnBgB,KAAK,EAAEH,IAHY;IAInBC;EAJmB,CAArB;EAOAD,IAAI,CAACgI,IAAL;AACD;;AAEc,SAASI,wBAAT,CACbpI,IADa,EAEbqI,QAFa,EAGbC,KAAK,GAAG,KAHK,EAIL;EACR,MAAM9H,KAAa,GAAG;IACpBoF,UAAU,EAAE,IAAI2C,GAAJ,EADQ;IAEpBtC,OAAO,EAAE,EAFW;IAGpBoC,QAHoB;IAIpB1H,OAAO,EAAE,EAJW;IAKpBwG,SAAS,EAAE;EALS,CAAtB;;EAQA,IAAI,CAACmB,KAAD,IAAUT,KAAK,CAAChC,GAAN,CAAU7F,IAAV,CAAd,EAA+B;IAAA;;IAC7B,qBAAO6H,KAAK,CAAC3H,GAAN,CAAUF,IAAV,CAAP,mDAA0BQ,KAA1B;EACD;;EAEDR,IAAI,CAACyB,QAAL,CACE;IACE+G,oBAAoB,EAAET,+BADxB;IAEEU,cAAc,EAAER,yBAFlB;IAGES,oBAAoB,EAAExB,+BAHxB;IAIEyB,wBAAwB,EAAEf,mCAJ5B;IAKEgB,sBAAsB,EAAErB,iCAL1B;IAMEsB,iBAAiB,EAAEtI,4BANrB;IAOEuI,MAAM,EAAEzF,wBAPV;IAQE3B,UAAU,EAAE2E;EARd,CADF,EAWE7F,KAXF;EAcAqH,KAAK,CAAC/B,GAAN,CAAU9F,IAAV,EAAgBQ,KAAhB;EAEA,OAAOA,KAAP;AACD"}