{"version":3,"file":"collectTemplateDependencies.js","names":["statement","cloneNode","debug","hasMeta","findIdentifiers","mutate","reference","referenceAll","ValueType","getSource","valueToLiteral","createId","name","loc","type","staticEval","ex","evaluate","undefined","result","confident","value","expressionDeclarationTpl","preserveComments","unsupported","reason","buildCodeFrameError","isIdentifier","getUidInRootScope","path","node","rootScope","scope","getProgramParent","hasBinding","generateUid","hoistVariableDeclarator","parent","referencedIdentifiers","forEach","identifier","hoistIdentifier","bindingIdentifiers","newName","rename","statementInRoot","findParent","p","parentPath","isProgram","declaration","kind","declarations","inserted","insertBefore","registerDeclaration","idPath","isReferenced","binding","getBinding","includes","bindingPath","isVariableDeclarator","getOrAddLinariaPreval","object","getData","prevalExport","expression","operator","left","property","computed","right","properties","programPath","pushContainer","get","setData","addIdentifierToLinariaPreval","newProperty","key","shorthand","extractExpression","addToExport","isFunction","isFunctionExpression","isArrowFunctionExpression","expUid","evaluated","id","evaluatedId","replaceWith","FUNCTION","LAZY","expId","callee","arguments","collectTemplateDependencies","quasi","quasis","expressions","length","expressionValues","map","bind","source","isExpression","extracted"],"sources":["../../src/utils/collectTemplateDependencies.ts"],"sourcesContent":["/* eslint @typescript-eslint/no-use-before-define: [\"error\", { \"functions\": false }] */\n\n/**\n * This file is a visitor that checks TaggedTemplateExpressions and look for Linaria css or styled templates.\n * For each template it makes a list of dependencies, try to evaluate expressions, and if it is not possible, mark them as lazy dependencies.\n */\n\nimport { statement } from '@babel/template';\nimport type { NodePath, Scope } from '@babel/traverse';\nimport type {\n  Expression,\n  ExpressionStatement,\n  Identifier,\n  ObjectExpression,\n  ObjectProperty,\n  Program,\n  Statement,\n  TaggedTemplateExpression,\n  TemplateElement,\n  TSType,\n  VariableDeclaration,\n  VariableDeclarator,\n  SourceLocation,\n  JSXIdentifier,\n} from '@babel/types';\nimport { cloneNode } from '@babel/types';\n\nimport { debug } from '@linaria/logger';\nimport { hasMeta } from '@linaria/tags';\nimport {\n  findIdentifiers,\n  mutate,\n  reference,\n  referenceAll,\n} from '@linaria/utils';\n\nimport type { ExpressionValue } from '../types';\nimport { ValueType } from '../types';\n\nimport getSource from './getSource';\nimport valueToLiteral from './vlueToLiteral';\n\nconst createId = (name: string, loc?: SourceLocation | null): Identifier => ({\n  type: 'Identifier',\n  name,\n  loc,\n});\n\nfunction staticEval(\n  ex: NodePath<Expression>,\n  evaluate = false\n): [unknown] | undefined {\n  if (!evaluate) return undefined;\n\n  const result = ex.evaluate();\n  if (result.confident && !hasMeta(result.value)) {\n    return [result.value];\n  }\n\n  return undefined;\n}\n\nconst expressionDeclarationTpl = statement(\n  'const %%expId%% = /*#__PURE__*/ () => %%expression%%',\n  {\n    preserveComments: true,\n  }\n);\n\nconst unsupported = (ex: NodePath, reason?: string): Error =>\n  ex.buildCodeFrameError(\n    `This ${\n      ex.isIdentifier() ? 'identifier' : 'expression'\n    } cannot be used in the template${reason ? `, because it ${reason}` : ''}.`\n  );\n\nfunction getUidInRootScope(path: NodePath<Identifier | JSXIdentifier>): string {\n  const { name } = path.node;\n  const rootScope = path.scope.getProgramParent();\n  if (rootScope.hasBinding(name)) {\n    return rootScope.generateUid(name);\n  }\n\n  return name;\n}\n\nfunction hoistVariableDeclarator(ex: NodePath<VariableDeclarator>) {\n  if (!ex.scope.parent) {\n    // It is already in the root scope\n    return;\n  }\n\n  const referencedIdentifiers = findIdentifiers([ex], 'referenced');\n  referencedIdentifiers.forEach((identifier) => {\n    if (identifier.isIdentifier()) {\n      hoistIdentifier(identifier);\n    }\n  });\n\n  const bindingIdentifiers = findIdentifiers([ex], 'binding');\n\n  bindingIdentifiers.forEach((path) => {\n    const newName = getUidInRootScope(path);\n    if (newName !== path.node.name) {\n      path.scope.rename(path.node.name, newName);\n    }\n  });\n\n  const rootScope = ex.scope.getProgramParent();\n\n  const statementInRoot = ex.findParent(\n    (p) => p.parentPath?.isProgram() === true\n  ) as NodePath<Statement>;\n\n  const declaration: VariableDeclaration = {\n    type: 'VariableDeclaration',\n    kind: 'let',\n    declarations: [cloneNode(ex.node)],\n  };\n\n  const [inserted] = statementInRoot.insertBefore(declaration);\n  referenceAll(inserted);\n  rootScope.registerDeclaration(inserted);\n}\n\nfunction hoistIdentifier(idPath: NodePath<Identifier>): void {\n  if (!idPath.isReferenced()) {\n    throw unsupported(idPath);\n  }\n\n  const binding = idPath.scope.getBinding(idPath.node.name);\n  if (!binding) {\n    // It's something strange\n    throw unsupported(idPath, 'is undefined');\n  }\n\n  if (binding.kind === 'module') {\n    // Modules are global by default\n    return;\n  }\n\n  if (!['var', 'let', 'const'].includes(binding.kind)) {\n    // This is not a variable, we can't hoist it\n    throw unsupported(binding.path, 'is a function parameter');\n  }\n\n  const { scope, path: bindingPath } = binding;\n  // parent here can be null or undefined in different versions of babel\n  if (!scope.parent) {\n    // The variable is already in the root scope\n    return;\n  }\n\n  if (bindingPath.isVariableDeclarator()) {\n    hoistVariableDeclarator(bindingPath);\n\n    return;\n  }\n\n  throw unsupported(idPath);\n}\n\nfunction getOrAddLinariaPreval(scope: Scope): NodePath<ObjectExpression> {\n  const rootScope = scope.getProgramParent();\n  let object = rootScope.getData('__linariaPreval');\n  if (object) {\n    return object;\n  }\n\n  const prevalExport: ExpressionStatement = {\n    type: 'ExpressionStatement',\n    expression: {\n      type: 'AssignmentExpression',\n      operator: '=',\n      left: {\n        type: 'MemberExpression',\n        object: createId('exports'),\n        property: createId('__linariaPreval'),\n        computed: false,\n      },\n      right: {\n        type: 'ObjectExpression',\n        properties: [],\n      },\n    },\n  };\n\n  const programPath = rootScope.path as NodePath<Program>;\n  const [inserted] = programPath.pushContainer('body', [prevalExport]);\n  object = inserted.get('expression.right') as NodePath<ObjectExpression>;\n  rootScope.setData('__linariaPreval', object);\n  return object;\n}\n\nfunction addIdentifierToLinariaPreval(scope: Scope, name: string) {\n  const rootScope = scope.getProgramParent();\n  const object = getOrAddLinariaPreval(rootScope);\n  const newProperty: ObjectProperty = {\n    type: 'ObjectProperty',\n    key: createId(name),\n    value: createId(name),\n    computed: false,\n    shorthand: false,\n  };\n\n  const [inserted] = object.pushContainer('properties', [newProperty]);\n  reference(inserted.get('value') as NodePath<Identifier>);\n}\n\n/**\n * Only an expression that can be evaluated in the root scope can be\n * used in a Linaria template. This function tries to hoist the expression.\n * @param ex The expression to hoist.\n * @param evaluate If true, we try to statically evaluate the expression.\n * @param addToExport If true, we add the expression to the __linariaPreval.\n */\nexport function extractExpression(\n  ex: NodePath<Expression>,\n  evaluate = false,\n  addToExport = true\n): Omit<ExpressionValue, 'buildCodeFrameError' | 'source'> {\n  const { loc } = ex.node;\n\n  const rootScope = ex.scope.getProgramParent();\n  const statementInRoot = ex.findParent(\n    (p) => p.parentPath?.isProgram() === true\n  ) as NodePath<Statement>;\n\n  const isFunction =\n    ex.isFunctionExpression() || ex.isArrowFunctionExpression();\n\n  // Generate next _expN name\n  const expUid = rootScope.generateUid('exp');\n\n  const evaluated = staticEval(ex, evaluate);\n\n  if (!evaluated) {\n    // If expression is not statically evaluable,\n    // we need to hoist all its referenced identifiers\n\n    // Collect all referenced identifiers\n    findIdentifiers([ex], 'referenced').forEach((id) => {\n      if (!id.isIdentifier()) return;\n\n      // Try to evaluate and inline them…\n      const evaluatedId = staticEval(id, evaluate);\n      if (evaluatedId) {\n        mutate(id, (p) => {\n          p.replaceWith(valueToLiteral(evaluatedId[0], ex));\n        });\n      } else {\n        // … or hoist them to the root scope\n        hoistIdentifier(id);\n      }\n    });\n  }\n\n  const kind = isFunction ? ValueType.FUNCTION : ValueType.LAZY;\n\n  // Declare _expN const with the lazy expression\n  const declaration = expressionDeclarationTpl({\n    expId: createId(expUid),\n    expression: evaluated\n      ? valueToLiteral(evaluated[0], ex)\n      : cloneNode(ex.node),\n  }) as VariableDeclaration;\n\n  // Insert the declaration as close as possible to the original expression\n  const [inserted] = statementInRoot.insertBefore(declaration);\n  referenceAll(inserted);\n  rootScope.registerDeclaration(inserted);\n\n  // Replace the expression with the _expN() call\n  mutate(ex, (p) => {\n    p.replaceWith({\n      type: 'CallExpression',\n      callee: createId(expUid),\n      arguments: [],\n    });\n  });\n\n  if (addToExport) {\n    addIdentifierToLinariaPreval(rootScope, expUid);\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  ex.node.loc = loc;\n\n  return {\n    kind,\n    ex: createId(expUid, loc),\n  };\n}\n\n/**\n * Collects, hoists, and makes lazy all expressions in the given template\n * If evaluate is true, it will try to evaluate the expressions\n */\nexport default function collectTemplateDependencies(\n  path: NodePath<TaggedTemplateExpression>,\n  evaluate = false\n): [quasis: TemplateElement[], expressionValues: ExpressionValue[]] {\n  const quasi = path.get('quasi');\n  const quasis = quasi.get('quasis');\n  const expressions = quasi.get('expressions');\n\n  debug('template-parse:identify-expressions', expressions.length);\n\n  const expressionValues: ExpressionValue[] = expressions.map(\n    (ex: NodePath<Expression | TSType>): ExpressionValue => {\n      const buildCodeFrameError = ex.buildCodeFrameError.bind(ex);\n      const source = getSource(ex);\n\n      if (!ex.isExpression()) {\n        throw buildCodeFrameError(\n          `The expression '${source}' is not supported.`\n        );\n      }\n\n      const extracted = extractExpression(ex, evaluate);\n\n      return {\n        ...extracted,\n        source,\n        buildCodeFrameError,\n      };\n    }\n  );\n\n  return [quasis.map((p) => p.node), expressionValues];\n}\n"],"mappings":"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"}