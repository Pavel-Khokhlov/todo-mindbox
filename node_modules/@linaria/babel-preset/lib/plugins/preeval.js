"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = preeval;

var _logger = require("@linaria/logger");

var _utils = require("@linaria/utils");

var _processTemplateExpression = _interopRequireDefault(require("../utils/processTemplateExpression"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This file is a babel preset used to transform files inside evaluators.
 * It works the same as main `babel/extract` preset, but do not evaluate lazy dependencies.
 */
const isGlobal = id => {
  const {
    scope
  } = id;
  const {
    name
  } = id.node;
  return !scope.hasBinding(name) && scope.hasGlobal(name);
};

const forbiddenGlobals = new Set(['XMLHttpRequest', 'clearImmediate', 'clearInterval', 'clearTimeout', 'document', 'fetch', 'localStorage', 'location', 'navigator', 'sessionStorage', 'setImmediate', 'setInterval', 'setTimeout', 'window']);

const isBrowserGlobal = id => {
  return forbiddenGlobals.has(id.node.name) && isGlobal(id);
};

function isHookOrCreateElement(name) {
  return name === 'createElement' || /use[A-Z]/.test(name);
}

function isUnnecessaryReact(p, imports) {
  const reactImports = imports.filter(i => i.source === 'react' && (i.imported === 'default' || i.imported && isHookOrCreateElement(i.imported)));
  if (reactImports.length === 0) return false;
  const callee = p.get('callee');

  if (callee.isIdentifier() && isHookOrCreateElement(callee.node.name)) {
    var _callee$scope$getBind;

    const bindingPath = (_callee$scope$getBind = callee.scope.getBinding(callee.node.name)) === null || _callee$scope$getBind === void 0 ? void 0 : _callee$scope$getBind.path;
    return reactImports.some(i => bindingPath === null || bindingPath === void 0 ? void 0 : bindingPath.isAncestor(i.local));
  }

  if (callee.isMemberExpression()) {
    var _object$scope$getBind, _bindingPath$isAncest;

    if (reactImports.some(i => i.local === callee)) {
      // It's React.createElement in CJS
      return true;
    }

    const object = callee.get('object');
    const property = callee.get('property');
    const defaultImport = reactImports.find(i => i.imported === 'default');

    if (!defaultImport || !defaultImport.local.isIdentifier() || !property.isIdentifier() || !isHookOrCreateElement(property.node.name) || !object.isIdentifier({
      name: defaultImport.local.node.name
    })) {
      return false;
    }

    const bindingPath = (_object$scope$getBind = object.scope.getBinding(object.node.name)) === null || _object$scope$getBind === void 0 ? void 0 : _object$scope$getBind.path;
    return (_bindingPath$isAncest = bindingPath === null || bindingPath === void 0 ? void 0 : bindingPath.isAncestor(defaultImport.local)) !== null && _bindingPath$isAncest !== void 0 ? _bindingPath$isAncest : false;
  }

  return false;
}

function preeval(babel, options) {
  const {
    types: t
  } = babel;
  return {
    name: '@linaria/babel/preeval',

    pre(file) {
      var _jsxRuntime$local, _jsxRuntime$local2, _jsxRuntime$local2$no;

      const log = (0, _logger.createCustomDebug)('preeval', (0, _utils.getFileIdx)(file.opts.filename));
      log('start', 'Looking for template literalsâ€¦');
      const {
        imports
      } = (0, _utils.collectExportsAndImports)(file.path, file.opts.filename);
      const jsxRuntime = imports.find(i => i.source === 'react/jsx-runtime');
      const jsxRuntimeName = (jsxRuntime === null || jsxRuntime === void 0 ? void 0 : (_jsxRuntime$local = jsxRuntime.local) === null || _jsxRuntime$local === void 0 ? void 0 : _jsxRuntime$local.isIdentifier()) && (jsxRuntime === null || jsxRuntime === void 0 ? void 0 : (_jsxRuntime$local2 = jsxRuntime.local) === null || _jsxRuntime$local2 === void 0 ? void 0 : (_jsxRuntime$local2$no = _jsxRuntime$local2.node) === null || _jsxRuntime$local2$no === void 0 ? void 0 : _jsxRuntime$local2$no.name);
      this.processors = [];
      file.path.traverse({
        Identifier: p => {
          (0, _processTemplateExpression.default)(p, file.opts, options, processor => {
            processor.doEvaltimeReplacement();
            this.processors.push(processor);
          });
        }
      });
      log('start', 'Strip all JSX and browser related stuff');
      file.path.traverse({
        // JSX can be replaced with a dummy value,
        // but we have to do it after we processed template tags.
        CallExpression: {
          enter(p) {
            if (jsxRuntimeName) {
              const callee = p.get('callee');

              if (callee.isIdentifier({
                name: jsxRuntimeName
              })) {
                (0, _utils.JSXElementsRemover)(p);
              }
            }

            if (isUnnecessaryReact(p, imports)) {
              (0, _utils.JSXElementsRemover)(p);
            }
          }

        },
        JSXElement: {
          enter: _utils.JSXElementsRemover
        },
        JSXFragment: {
          enter: _utils.JSXElementsRemover
        },

        Identifier(p) {
          if (isBrowserGlobal(p)) {
            if (p.parentPath.isUnaryExpression({
              operator: 'typeof'
            })) {
              // Ignore `typeof window` expressions
              return;
            }

            (0, _utils.removeWithRelated)([p]);
          }
        }

      });
    },

    visitor: {},

    post(file) {
      const log = (0, _logger.createCustomDebug)('preeval', (0, _utils.getFileIdx)(file.opts.filename));

      if (this.processors.length === 0) {
        log('end', "We didn't find any Linaria template literals"); // We didn't find any Linaria template literals.

        return;
      }

      this.file.metadata.linaria = {
        processors: this.processors,
        replacements: [],
        rules: {},
        dependencies: []
      };
      const expressions = this.processors.flatMap(processor => processor.dependencies.map(dependency => dependency.ex));
      const linariaPreval = file.path.scope.getData('__linariaPreval');

      if (!linariaPreval) {
        const linariaExport = t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.identifier('exports'), t.identifier('__linariaPreval')), t.objectExpression(expressions.map(ex => t.objectProperty(ex, ex, false, true)))));
        file.path.pushContainer('body', linariaExport);
      }

      log('end', '__linariaPreval has been added');
    }

  };
}
//# sourceMappingURL=preeval.js.map