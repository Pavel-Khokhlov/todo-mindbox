"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = prepareForRuntime;

var babel = _interopRequireWildcard(require("@babel/core"));

var _utils = require("@linaria/utils");

var _cachedParseSync = _interopRequireDefault(require("./helpers/cachedParseSync"));

var _loadLinariaOptions = _interopRequireDefault(require("./helpers/loadLinariaOptions"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Parses the specified file, finds tags, applies run-time replacements,
 * removes dead code.
 */
function prepareForRuntime(code, valueCache, options, babelConfig) {
  var _babelConfig$filename, _babelConfig$filename2, _result$ast;

  const pluginOptions = (0, _loadLinariaOptions.default)(options.pluginOptions);
  const babelOptions = (0, _utils.loadBabelOptions)(options.filename, pluginOptions === null || pluginOptions === void 0 ? void 0 : pluginOptions.babelOptions);
  const file = (0, _cachedParseSync.default)(code, babelOptions);
  const transformPlugins = [[require.resolve('../plugins/collector'), { ...pluginOptions,
    values: valueCache
  }]];
  const transformConfig = (0, _utils.buildOptions)({
    envName: 'linaria',
    plugins: transformPlugins,
    sourceMaps: true,
    sourceFileName: (_babelConfig$filename = babelConfig.filename) !== null && _babelConfig$filename !== void 0 ? _babelConfig$filename : options.filename,
    inputSourceMap: options.inputSourceMap,
    root: options.root,
    ast: true,
    babelrc: false,
    configFile: false
  });
  const result = babel.transformFromAstSync(file, code, { ...transformConfig,
    cwd: babelConfig.cwd,
    filename: (_babelConfig$filename2 = babelConfig.filename) !== null && _babelConfig$filename2 !== void 0 ? _babelConfig$filename2 : options.filename
  });

  if (!result || !((_result$ast = result.ast) !== null && _result$ast !== void 0 && _result$ast.program)) {
    throw new Error('Babel transform failed');
  }

  return result;
}
//# sourceMappingURL=3-prepare-for-runtime.js.map