"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = prepareForEval;
exports.prepareForEvalSync = prepareForEvalSync;

var _fs = require("fs");

var _path = require("path");

var babel = _interopRequireWildcard(require("@babel/core"));

var _logger = require("@linaria/logger");

var _utils = require("@linaria/utils");

var _withLinariaMetadata = _interopRequireDefault(require("../utils/withLinariaMetadata"));

var _cachedParseSync = _interopRequireDefault(require("./helpers/cachedParseSync"));

var _loadLinariaOptions = _interopRequireDefault(require("./helpers/loadLinariaOptions"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const isModuleResolver = i => typeof i === 'object' && i !== null && i.key === 'module-resolver';

function runPreevalStage(filename, code, options, perFileBabelConfig) {
  var _fullParserOptions$pl, _result$ast;

  const pluginOptions = (0, _loadLinariaOptions.default)(options.pluginOptions);
  const parseConfig = (0, _utils.buildOptions)(pluginOptions === null || pluginOptions === void 0 ? void 0 : pluginOptions.babelOptions, perFileBabelConfig);
  const fullParserOptions = (0, _utils.loadBabelOptions)(filename, parseConfig);
  const file = (0, _cachedParseSync.default)(code, fullParserOptions);
  const transformPlugins = [[require.resolve('../plugins/preeval'), pluginOptions]];
  const moduleResolverPlugin = (_fullParserOptions$pl = fullParserOptions.plugins) === null || _fullParserOptions$pl === void 0 ? void 0 : _fullParserOptions$pl.find(isModuleResolver);

  if (moduleResolverPlugin) {
    transformPlugins.unshift(moduleResolverPlugin);
  }

  const transformConfig = (0, _utils.buildOptions)({
    envName: 'linaria',
    plugins: transformPlugins,
    sourceMaps: true,
    sourceFileName: filename,
    inputSourceMap: options.inputSourceMap,
    root: options.root,
    ast: true,
    babelrc: false,
    configFile: false
  });
  const result = babel.transformFromAstSync(file, code, { ...transformConfig,
    filename
  });

  if (!result || !((_result$ast = result.ast) !== null && _result$ast !== void 0 && _result$ast.program)) {
    throw new Error('Babel transform failed');
  }

  return result;
}

function getMatchedRule(rules, filename, code) {
  for (let i = rules.length - 1; i >= 0; i--) {
    const rule = rules[i];

    if (!rule.test) {
      return rule;
    }

    if (typeof rule.test === 'function' && rule.test(filename, code)) {
      return rule;
    }

    if (rule.test instanceof RegExp && rule.test.test(filename)) {
      return rule;
    }
  }

  return {
    action: 'ignore'
  };
}

function prepareCode(filename, originalCode, only, options, fileCache) {
  const log = (0, _logger.createCustomDebug)('transform', (0, _utils.getFileIdx)(filename));
  const pluginOptions = (0, _loadLinariaOptions.default)(options.pluginOptions);
  const {
    action,
    babelOptions
  } = getMatchedRule(pluginOptions.rules, filename, originalCode);

  if (action === 'ignore') {
    log('stage-1:ignore', '');
    fileCache.set('*', {
      code: originalCode
    });
    return [originalCode, null];
  }

  const preevalStageResult = runPreevalStage(filename, originalCode, options, babelOptions);

  if (only.length === 1 && only[0] === '__linariaPreval' && !(0, _withLinariaMetadata.default)(preevalStageResult.metadata)) {
    log('stage-1:evaluator:end', 'no metadata');
    return [preevalStageResult.code, null, preevalStageResult.metadata];
  }

  log('stage-1:preeval', 'metadata %O', preevalStageResult.metadata); // Action can be a function or a module name

  const evaluator = typeof action === 'function' ? action : require(require.resolve(action, {
    paths: [(0, _path.dirname)(filename)]
  })).default;
  log('stage-1:evaluator:start', 'using %s', evaluator.name);
  const result = evaluator(filename, pluginOptions, preevalStageResult.code, only);
  log('stage-1:evaluator:end', '');
  return [...result, preevalStageResult.metadata];
}

function processQueueItem(item, codeCache, options) {
  if (!item) {
    return undefined;
  }

  const pluginOptions = (0, _loadLinariaOptions.default)(options.pluginOptions);
  const results = new Set();
  const {
    name,
    only,
    code
  } = item;

  if (!codeCache.has(name)) {
    codeCache.set(name, new Map());
  }

  const log = (0, _logger.createCustomDebug)('transform', (0, _utils.getFileIdx)(name));
  const extension = (0, _path.extname)(name);

  if (!pluginOptions.extensions.includes(extension)) {
    log('init', `${name} is ignored. If you want it to be processed, you should add '${extension}' to the "extensions" option.`);
    return undefined;
  }

  log('init', `${name} (${only.join(', ')})\n${code}`);
  const uncachedExports = new Set(only);
  const fileCache = codeCache.get(name);
  uncachedExports.forEach(token => {
    if (fileCache.has(token)) {
      uncachedExports.delete(token);
      results.add(fileCache.get(token));
    }
  });

  if (uncachedExports.size === 0) {
    // Already processed
    return {
      imports: null,
      name,
      results: Array.from(results)
    };
  }

  const remainExports = Array.from(uncachedExports);
  log('stage-1', `>> (${remainExports.join(', ')})`);
  const [preparedCode, imports, metadata] = prepareCode(name, code, remainExports, options, fileCache);

  if (code === preparedCode) {
    log('stage-1', `<< (${remainExports.join(', ')})\n === no changes ===`);
  } else {
    log('stage-1', `<< (${remainExports.join(', ')})\n${preparedCode}`);
  }

  const result = {
    metadata,
    code: preparedCode
  };
  results.add(result);
  remainExports.forEach(token => {
    fileCache.set(token, result);
  });
  if (preparedCode === '') return undefined;
  return {
    imports,
    name,
    results: Array.from(results)
  };
}

function prepareForEvalSync(resolveCache, codeCache, resolve, resolvedFile, options, stack = []) {
  const processed = processQueueItem(resolvedFile, codeCache, options);
  if (!processed) return undefined;
  const {
    imports,
    name,
    results
  } = processed;
  const log = (0, _logger.createCustomDebug)('transform', (0, _utils.getFileIdx)(name));
  const queue = [];
  imports === null || imports === void 0 ? void 0 : imports.forEach((importsOnly, importedFile) => {
    try {
      const resolved = resolve(importedFile, name, stack);
      log('stage-1:sync-resolve', `✅ ${importedFile} -> ${resolved}`);
      resolveCache.set(`${name} -> ${importedFile}`, `${resolved}\0${importsOnly.join(',')}`);
      const fileContent = (0, _fs.readFileSync)(resolved, 'utf8');
      queue.push({
        name: resolved,
        only: importsOnly,
        code: fileContent
      });
    } catch (err) {
      log('stage-1:sync-resolve', `❌ cannot resolve ${importedFile}: %O`, err);
    }
  });
  queue.forEach(item => {
    prepareForEvalSync(resolveCache, codeCache, resolve, item, options, [name, ...stack]);
  });
  return Array.from(results);
}
/**
 * Parses the specified file and recursively all its dependencies,
 * finds tags, applies eval-time replacements, removes dead code.
 */


async function prepareForEval(resolveCache, codeCache, resolve, file, options, stack = []) {
  const resolvedFile = await file;
  const processed = processQueueItem(resolvedFile, codeCache, options);
  if (!processed) return undefined;
  const {
    imports,
    name,
    results
  } = processed;
  const log = (0, _logger.createCustomDebug)('transform', (0, _utils.getFileIdx)(name));
  const promises = [];
  imports === null || imports === void 0 ? void 0 : imports.forEach((importsOnly, importedFile) => {
    const promise = resolve(importedFile, name, stack).then(resolved => {
      log('stage-1:async-resolve', `✅ ${importedFile} -> ${resolved}`);
      const resolveCacheKey = `${name} -> ${importedFile}`;
      const cached = resolveCache.get(resolveCacheKey);
      const importsOnlySet = new Set(importsOnly);

      if (cached) {
        const [, cachedOnly] = cached.split('\0');
        cachedOnly === null || cachedOnly === void 0 ? void 0 : cachedOnly.split(',').forEach(token => {
          importsOnlySet.add(token);
        });
      }

      resolveCache.set(resolveCacheKey, `${resolved}\0${[...importsOnlySet].join(',')}`);
      const fileContent = (0, _fs.readFileSync)(resolved, 'utf8');
      return {
        name: resolved,
        only: importsOnly,
        code: fileContent
      };
    }, err => {
      log('stage-1:async-resolve', `❌ cannot resolve ${importedFile}: %O`, err);
      return null;
    });
    promises.push(prepareForEval(resolveCache, codeCache, resolve, promise, options, [name, ...stack]));
  });
  await Promise.all(promises);
  return Array.from(results);
}
//# sourceMappingURL=1-prepare-for-eval.js.map