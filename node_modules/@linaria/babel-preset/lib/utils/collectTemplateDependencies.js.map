{"version":3,"file":"collectTemplateDependencies.js","names":["createId","name","loc","type","staticEval","ex","evaluate","undefined","result","confident","hasMeta","value","expressionDeclarationTpl","statement","preserveComments","unsupported","reason","buildCodeFrameError","isIdentifier","getUidInRootScope","path","node","rootScope","scope","getProgramParent","hasBinding","generateUid","hoistVariableDeclarator","parent","referencedIdentifiers","findIdentifiers","forEach","identifier","hoistIdentifier","bindingIdentifiers","newName","rename","statementInRoot","findParent","p","parentPath","isProgram","declaration","kind","declarations","cloneNode","inserted","insertBefore","referenceAll","registerDeclaration","idPath","isReferenced","binding","getBinding","includes","bindingPath","isVariableDeclarator","getOrAddLinariaPreval","object","getData","prevalExport","expression","operator","left","property","computed","right","properties","programPath","pushContainer","get","setData","addIdentifierToLinariaPreval","newProperty","key","shorthand","reference","extractExpression","addToExport","isFunction","isFunctionExpression","isArrowFunctionExpression","expUid","evaluated","id","evaluatedId","mutate","replaceWith","valueToLiteral","ValueType","FUNCTION","LAZY","expId","callee","arguments","collectTemplateDependencies","quasi","quasis","expressions","debug","length","expressionValues","map","bind","source","getSource","isExpression","extracted"],"sources":["../../src/utils/collectTemplateDependencies.ts"],"sourcesContent":["/* eslint @typescript-eslint/no-use-before-define: [\"error\", { \"functions\": false }] */\n\n/**\n * This file is a visitor that checks TaggedTemplateExpressions and look for Linaria css or styled templates.\n * For each template it makes a list of dependencies, try to evaluate expressions, and if it is not possible, mark them as lazy dependencies.\n */\n\nimport { statement } from '@babel/template';\nimport type { NodePath, Scope } from '@babel/traverse';\nimport type {\n  Expression,\n  ExpressionStatement,\n  Identifier,\n  ObjectExpression,\n  ObjectProperty,\n  Program,\n  Statement,\n  TaggedTemplateExpression,\n  TemplateElement,\n  TSType,\n  VariableDeclaration,\n  VariableDeclarator,\n  SourceLocation,\n  JSXIdentifier,\n} from '@babel/types';\nimport { cloneNode } from '@babel/types';\n\nimport { debug } from '@linaria/logger';\nimport { hasMeta } from '@linaria/tags';\nimport {\n  findIdentifiers,\n  mutate,\n  reference,\n  referenceAll,\n} from '@linaria/utils';\n\nimport type { ExpressionValue } from '../types';\nimport { ValueType } from '../types';\n\nimport getSource from './getSource';\nimport valueToLiteral from './vlueToLiteral';\n\nconst createId = (name: string, loc?: SourceLocation | null): Identifier => ({\n  type: 'Identifier',\n  name,\n  loc,\n});\n\nfunction staticEval(\n  ex: NodePath<Expression>,\n  evaluate = false\n): [unknown] | undefined {\n  if (!evaluate) return undefined;\n\n  const result = ex.evaluate();\n  if (result.confident && !hasMeta(result.value)) {\n    return [result.value];\n  }\n\n  return undefined;\n}\n\nconst expressionDeclarationTpl = statement(\n  'const %%expId%% = /*#__PURE__*/ () => %%expression%%',\n  {\n    preserveComments: true,\n  }\n);\n\nconst unsupported = (ex: NodePath, reason?: string): Error =>\n  ex.buildCodeFrameError(\n    `This ${\n      ex.isIdentifier() ? 'identifier' : 'expression'\n    } cannot be used in the template${reason ? `, because it ${reason}` : ''}.`\n  );\n\nfunction getUidInRootScope(path: NodePath<Identifier | JSXIdentifier>): string {\n  const { name } = path.node;\n  const rootScope = path.scope.getProgramParent();\n  if (rootScope.hasBinding(name)) {\n    return rootScope.generateUid(name);\n  }\n\n  return name;\n}\n\nfunction hoistVariableDeclarator(ex: NodePath<VariableDeclarator>) {\n  if (!ex.scope.parent) {\n    // It is already in the root scope\n    return;\n  }\n\n  const referencedIdentifiers = findIdentifiers([ex], 'referenced');\n  referencedIdentifiers.forEach((identifier) => {\n    if (identifier.isIdentifier()) {\n      hoistIdentifier(identifier);\n    }\n  });\n\n  const bindingIdentifiers = findIdentifiers([ex], 'binding');\n\n  bindingIdentifiers.forEach((path) => {\n    const newName = getUidInRootScope(path);\n    if (newName !== path.node.name) {\n      path.scope.rename(path.node.name, newName);\n    }\n  });\n\n  const rootScope = ex.scope.getProgramParent();\n\n  const statementInRoot = ex.findParent(\n    (p) => p.parentPath?.isProgram() === true\n  ) as NodePath<Statement>;\n\n  const declaration: VariableDeclaration = {\n    type: 'VariableDeclaration',\n    kind: 'let',\n    declarations: [cloneNode(ex.node)],\n  };\n\n  const [inserted] = statementInRoot.insertBefore(declaration);\n  referenceAll(inserted);\n  rootScope.registerDeclaration(inserted);\n}\n\nfunction hoistIdentifier(idPath: NodePath<Identifier>): void {\n  if (!idPath.isReferenced()) {\n    throw unsupported(idPath);\n  }\n\n  const binding = idPath.scope.getBinding(idPath.node.name);\n  if (!binding) {\n    // It's something strange\n    throw unsupported(idPath, 'is undefined');\n  }\n\n  if (binding.kind === 'module') {\n    // Modules are global by default\n    return;\n  }\n\n  if (!['var', 'let', 'const'].includes(binding.kind)) {\n    // This is not a variable, we can't hoist it\n    throw unsupported(binding.path, 'is a function parameter');\n  }\n\n  const { scope, path: bindingPath } = binding;\n  // parent here can be null or undefined in different versions of babel\n  if (!scope.parent) {\n    // The variable is already in the root scope\n    return;\n  }\n\n  if (bindingPath.isVariableDeclarator()) {\n    hoistVariableDeclarator(bindingPath);\n\n    return;\n  }\n\n  throw unsupported(idPath);\n}\n\nfunction getOrAddLinariaPreval(scope: Scope): NodePath<ObjectExpression> {\n  const rootScope = scope.getProgramParent();\n  let object = rootScope.getData('__linariaPreval');\n  if (object) {\n    return object;\n  }\n\n  const prevalExport: ExpressionStatement = {\n    type: 'ExpressionStatement',\n    expression: {\n      type: 'AssignmentExpression',\n      operator: '=',\n      left: {\n        type: 'MemberExpression',\n        object: createId('exports'),\n        property: createId('__linariaPreval'),\n        computed: false,\n      },\n      right: {\n        type: 'ObjectExpression',\n        properties: [],\n      },\n    },\n  };\n\n  const programPath = rootScope.path as NodePath<Program>;\n  const [inserted] = programPath.pushContainer('body', [prevalExport]);\n  object = inserted.get('expression.right') as NodePath<ObjectExpression>;\n  rootScope.setData('__linariaPreval', object);\n  return object;\n}\n\nfunction addIdentifierToLinariaPreval(scope: Scope, name: string) {\n  const rootScope = scope.getProgramParent();\n  const object = getOrAddLinariaPreval(rootScope);\n  const newProperty: ObjectProperty = {\n    type: 'ObjectProperty',\n    key: createId(name),\n    value: createId(name),\n    computed: false,\n    shorthand: false,\n  };\n\n  const [inserted] = object.pushContainer('properties', [newProperty]);\n  reference(inserted.get('value') as NodePath<Identifier>);\n}\n\n/**\n * Only an expression that can be evaluated in the root scope can be\n * used in a Linaria template. This function tries to hoist the expression.\n * @param ex The expression to hoist.\n * @param evaluate If true, we try to statically evaluate the expression.\n * @param addToExport If true, we add the expression to the __linariaPreval.\n */\nexport function extractExpression(\n  ex: NodePath<Expression>,\n  evaluate = false,\n  addToExport = true\n): Omit<ExpressionValue, 'buildCodeFrameError' | 'source'> {\n  const { loc } = ex.node;\n\n  const rootScope = ex.scope.getProgramParent();\n  const statementInRoot = ex.findParent(\n    (p) => p.parentPath?.isProgram() === true\n  ) as NodePath<Statement>;\n\n  const isFunction =\n    ex.isFunctionExpression() || ex.isArrowFunctionExpression();\n\n  // Generate next _expN name\n  const expUid = rootScope.generateUid('exp');\n\n  const evaluated = staticEval(ex, evaluate);\n\n  if (!evaluated) {\n    // If expression is not statically evaluable,\n    // we need to hoist all its referenced identifiers\n\n    // Collect all referenced identifiers\n    findIdentifiers([ex], 'referenced').forEach((id) => {\n      if (!id.isIdentifier()) return;\n\n      // Try to evaluate and inline them…\n      const evaluatedId = staticEval(id, evaluate);\n      if (evaluatedId) {\n        mutate(id, (p) => {\n          p.replaceWith(valueToLiteral(evaluatedId[0], ex));\n        });\n      } else {\n        // … or hoist them to the root scope\n        hoistIdentifier(id);\n      }\n    });\n  }\n\n  const kind = isFunction ? ValueType.FUNCTION : ValueType.LAZY;\n\n  // Declare _expN const with the lazy expression\n  const declaration = expressionDeclarationTpl({\n    expId: createId(expUid),\n    expression: evaluated\n      ? valueToLiteral(evaluated[0], ex)\n      : cloneNode(ex.node),\n  }) as VariableDeclaration;\n\n  // Insert the declaration as close as possible to the original expression\n  const [inserted] = statementInRoot.insertBefore(declaration);\n  referenceAll(inserted);\n  rootScope.registerDeclaration(inserted);\n\n  // Replace the expression with the _expN() call\n  mutate(ex, (p) => {\n    p.replaceWith({\n      type: 'CallExpression',\n      callee: createId(expUid),\n      arguments: [],\n    });\n  });\n\n  if (addToExport) {\n    addIdentifierToLinariaPreval(rootScope, expUid);\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  ex.node.loc = loc;\n\n  return {\n    kind,\n    ex: createId(expUid, loc),\n  };\n}\n\n/**\n * Collects, hoists, and makes lazy all expressions in the given template\n * If evaluate is true, it will try to evaluate the expressions\n */\nexport default function collectTemplateDependencies(\n  path: NodePath<TaggedTemplateExpression>,\n  evaluate = false\n): [quasis: TemplateElement[], expressionValues: ExpressionValue[]] {\n  const quasi = path.get('quasi');\n  const quasis = quasi.get('quasis');\n  const expressions = quasi.get('expressions');\n\n  debug('template-parse:identify-expressions', expressions.length);\n\n  const expressionValues: ExpressionValue[] = expressions.map(\n    (ex: NodePath<Expression | TSType>): ExpressionValue => {\n      const buildCodeFrameError = ex.buildCodeFrameError.bind(ex);\n      const source = getSource(ex);\n\n      if (!ex.isExpression()) {\n        throw buildCodeFrameError(\n          `The expression '${source}' is not supported.`\n        );\n      }\n\n      const extracted = extractExpression(ex, evaluate);\n\n      return {\n        ...extracted,\n        source,\n        buildCodeFrameError,\n      };\n    }\n  );\n\n  return [quasis.map((p) => p.node), expressionValues];\n}\n"],"mappings":"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"}